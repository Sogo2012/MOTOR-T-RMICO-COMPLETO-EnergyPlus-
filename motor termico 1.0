# -*- coding: utf-8 -*-
"""MOTOR TÉRMICO COMPLETO Claude .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q2niLGwTZLYdWMSQdmWWlUZccFzKf2ab

# -*- coding: utf-8 -*-
'''
======================================================================╗
         SKYCALC 2.0 - MOTOR TÉRMICO COMPLETO (EnergyPlus)          
         Eco Consultor | Sunoptics LATAM                             
         Versión: 3.0 | Para Google Colab (T4 GPU / CPU)            
======================================================================╝

ARQUITECTURA:
  1. Instalación de infraestructura (EnergyPlus + LBT)
  2. Construcción del gemelo digital (Honeybee + Dragonfly)
  3. Asignación de propiedades energéticas ASHRAE (ProgramType + HVAC)
  4. Descarga del archivo climático EPW (OneBuilding / vía weather_utils)
  5. Traducción y ejecución con EnergyPlus
  6. Extraccion de resultados del SQL a DataFrame limpio
  7. Visualización: Curva de optimización SFR (Split-Flux)
  8. Función exportable para integración con app.py de Streamlit

COMPATIBILIDAD: Diseñado para NO romper nada en app.py existente.
El resultado final es la función `simular_nave_sunoptics()` que
puede ser importada directamente desde motor_termico.py en Streamlit.
'''
"""

import subprocess, sys, os

def pip(pkg):
    subprocess.run([sys.executable, "-m", "pip", "install", "-q", pkg], check=False)

print("Instalando Ladybug Tools...")

pip("pydantic<2.0")
pip("numpy==1.26.4")
pip("ladybug-geometry==1.33.11")
pip("ladybug-core==0.43.18")
pip("honeybee-core==1.60.0")
pip("honeybee-energy==1.109.27")
pip("dragonfly-core==1.57.11")
pip("lbt-dragonfly")
pip("honeybee-openstudio")
pip("setuptools")
pip("pandas matplotlib plotly requests beautifulsoup4 geopy")

print("Instalando EnergyPlus 23.2.0...")

EP_TAR = "EnergyPlus-23.2.0-7636e6b3e9-Linux-Ubuntu22.04-x86_64.tar.gz"
EP_URL = f"https://github.com/NREL/EnergyPlus/releases/download/v23.2.0/{EP_TAR}"
EP_DIR = EP_TAR.replace(".tar.gz", "")

if not os.path.exists("/usr/local/energyplus"):
    os.system(f"wget -q {EP_URL}")
    os.system(f"tar -xzf {EP_TAR}")
    os.system(f"sudo cp -r {EP_DIR}/. /usr/local/")
    os.system("sudo ln -sf /usr/local/energyplus /usr/local/bin/energyplus 2>/dev/null || true")

result = subprocess.run(["energyplus", "--version"], capture_output=True, text=True)
if "EnergyPlus" in result.stdout:
    print(f"EnergyPlus listo: {result.stdout.strip()}")
else:
    print("EnergyPlus instalado. Verificar manualmente.")

print("INSTALACION COMPLETA.")
print("Siguiente: Runtime -> Restart session -> ejecuta desde Celda 2.")

# ==========================================================
# CELDA 2: IMPORTACIONES
# ==========================================================

import json
import math
import sqlite3
import shutil
import tempfile
import urllib.request
import zipfile
import warnings
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
import plotly.graph_objects as go

# Ladybug / Honeybee
from ladybug_geometry.geometry3d.pointvector import Point3D
from ladybug_geometry.geometry3d.face import Face3D
from dragonfly.model import Model as DFModel
from dragonfly.building import Building
from dragonfly.story import Story
from dragonfly.room2d import Room2D
from honeybee.aperture import Aperture
from honeybee.boundarycondition import Outdoors

# Honeybee Energy (propiedades térmicas)
from honeybee_energy.lib.programtypes import program_type_by_identifier
from honeybee_energy.lib.constructionsets import construction_set_by_identifier
from honeybee_energy.simulation.parameter import SimulationParameter
from honeybee_energy.simulation.output import SimulationOutput
from honeybee_energy.result.loadbalance import LoadBalance

print("OK: Todas las importaciones exitosas.")

# ==========================================================
# CELDA 3: PARÁMETROS DEL PROYECTO (EDITAR AQUÍ)
# ==========================================================

# --- Geometría de la Nave ---
ANCHO       = 50.0    # metros
LARGO       = 100.0   # metros
ALTURA      = 8.0     # metros

# --- Domo Sunoptics (Modelo 4080 DGZ) ---
DOMO_VLT    = 0.67    # Visible Light Transmittance
DOMO_SHGC   = 0.48    # Solar Heat Gain Coefficient
DOMO_U      = 3.20    # W/(m²·K) — Doble acristalamiento
DOMO_ANCHO  = 1.3279  # metros (52.25 in)
DOMO_LARGO  = 2.5465  # metros (100.25 in)

# --- Simulación SFR (para la curva de optimización) ---
# Se simularán estos 10 casos: [1%, 2%, 3%, 4%, 5%, 6%, 7%, 8%, 9%, 10%]
SFR_VALORES = np.arange(0.01, 0.11, 0.01)

# --- Programa de Uso (ASHRAE 90.1) ---
# Opciones verificadas en LBT: "Generic Office Program", "Generic Retail Program"
# Para bodega/industrial usamos parámetros manuales (ver más abajo)
TIPO_USO    = "warehouse"   # "warehouse" | "manufacturing" | "office"

# --- HVAC ---
COP_COOLING  = 3.5   # Coeficiente de rendimiento enfriamiento
EFF_HEATING  = 0.85  # Eficiencia calefacción (gas)
T_COOLING    = 24.0  # grados C setpoint enfriamiento
T_HEATING    = 18.0  # grados C setpoint calefaccion

# --- Ubicación (para EPW) ---
LAT  = 20.5888   # Querétaro, México (cambiar por coordenadas del proyecto)
LON  = -100.3899

print("OK: Parametros configurados correctamente.")

# ==========================================================
# CELDA 4: DESCARGA DEL ARCHIVO EPW
# ==========================================================
# Usa el mismo protocolo de weather_utils.py de Streamlit para
# garantizar compatibilidad. También acepta un path local.

def descargar_epw_onebuilding(lat, lon, carpeta_destino="/content"):
    """
    Localiza y descarga el archivo EPW más cercano desde climate.onebuilding.org
    Retorna la ruta local del archivo .epw descargado.
    Compatible con weather_utils.py de la app Streamlit.
    """
    import requests
    from bs4 import BeautifulSoup
    from geopy.distance import geodesic
    from geopy.geocoders import Photon

    print(f"Buscando estacion EPW para ({lat:.3f}, {lon:.3f})...")

    # 1. Geocodificación inversa → país
    try:
        geolocator = Photon(user_agent="skycalc_colab_v3")
        loc = geolocator.reverse(f"{lat}, {lon}", timeout=10)
        pais_raw = loc.raw.get("properties", {}).get("country", "Mexico")
    except Exception:
        pais_raw = "Mexico"

    print(f"   País detectado: {pais_raw}")

    # 2. Mapeo País → URL OneBuilding (subconjunto del onebuilding_mapping.json)
    MAPEO_PAISES = {
        "mexico":       "https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/MEX_Mexico/",
        "costa rica":   "https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/CRI_Costa_Rica/",
        "colombia":     "https://climate.onebuilding.org/WMO_Region_3_South_America/COL_Colombia/",
        "united states":"https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/USA_United_States_of_America/",
        "spain":        "https://climate.onebuilding.org/WMO_Region_6_Europe/ESP_Spain/",
        "chile":        "https://climate.onebuilding.org/WMO_Region_3_South_America/CHL_Chile/",
        "peru":         "https://climate.onebuilding.org/WMO_Region_3_South_America/PER_Peru/",
        "brazil":       "https://climate.onebuilding.org/WMO_Region_3_South_America/BRA_Brazil/",
        "argentina":    "https://climate.onebuilding.org/WMO_Region_3_South_America/ARG_Argentina/",
    }

    pais_norm = pais_raw.lower().strip()
    url_base = None
    for k, v in MAPEO_PAISES.items():
        if k in pais_norm:
            url_base = v
            break

    if not url_base:
        # Fallback: México
        url_base = MAPEO_PAISES["mexico"]
        print("   AVISO: Pais no mapeado, usando Mexico como fallback.")

    # 3. Scraping sigiloso de la página de OneBuilding
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    }

    try:
        resp = requests.get(url_base, headers=headers, timeout=20)
        soup = BeautifulSoup(resp.text, "html.parser")
        links = [a["href"] for a in soup.find_all("a", href=True)
                 if a["href"].endswith(".zip") and "TMYx" in a["href"]]
    except Exception as e:
        raise RuntimeError(f"Error al acceder a OneBuilding: {e}")

    if not links:
        raise RuntimeError("No se encontraron archivos TMYx en la URL base.")

    # 4. Geocodificar las primeras estaciones y calcular distancia Haversine
    print(f"   Encontradas {len(links)} estaciones. Calculando distancias...")

    def haversine(lat1, lon1, lat2, lon2):
        R = 6371
        dlat = math.radians(lat2 - lat1)
        dlon = math.radians(lon2 - lon1)
        a = (math.sin(dlat/2)**2 +
             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2)
        return R * 2 * math.asin(math.sqrt(a))

    import re, time, random
    mejor_url = None
    mejor_dist = float("inf")
    geolocator2 = Photon(user_agent=f"skycalc_{random.randint(100,999)}")

    for href in links[:20]:  # Revisar las primeras 20 para velocidad
        try:
            # Extraer nombre de ciudad del nombre del archivo
            fname = href.split("/")[-1].replace(".zip", "")
            ciudad_epw = re.sub(r"_TMYx.*", "", fname)
            ciudad_epw = "_".join(ciudad_epw.split("_")[2:]).replace("_", " ").replace(".", " ")

            query = f"{ciudad_epw}, {pais_raw}"
            geo_loc = geolocator2.geocode(query, timeout=5)
            if geo_loc:
                dist = haversine(lat, lon, geo_loc.latitude, geo_loc.longitude)
                if dist < mejor_dist:
                    mejor_dist = dist
                    mejor_url = url_base + href if not href.startswith("http") else href
            time.sleep(0.3)  # Rate limiting para no ser bloqueado
        except Exception:
            continue

    if not mejor_url:
        # Fallback: primera estación disponible
        mejor_url = url_base + links[0]
        mejor_dist = 9999

    print(f"   Estacion seleccionada ({mejor_dist:.1f} km): {mejor_url.split('/')[-1]}")

    # 5. Descargar y extraer el .epw
    zip_path = os.path.join(carpeta_destino, "clima_epw.zip")
    req = urllib.request.Request(mejor_url, headers=headers)
    with urllib.request.urlopen(req) as response:
        with open(zip_path, "wb") as f:
            shutil.copyfileobj(response, f)

    epw_path = None
    with zipfile.ZipFile(zip_path, "r") as z:
        z.extractall(carpeta_destino)
        for fname in z.namelist():
            if fname.endswith(".epw"):
                epw_path = os.path.join(carpeta_destino, fname)
                break

    if not epw_path:
        raise RuntimeError("No se encontró archivo .epw dentro del ZIP.")

    print(f"   EPW listo en: {epw_path}")
    return epw_path

# ==========================================================
# CELDA 5: CONSTRUCTOR DEL MODELO HONEYBEE
# ==========================================================

def construir_modelo_hb(ancho, largo, altura, sfr, domo_ancho, domo_largo,
                        tipo_uso="warehouse", domo_vlt=0.67, domo_shgc=0.48, domo_u=3.2,
                        identifier_sufijo=""):
    """
    Construye un modelo Honeybee completo con propiedades energéticas ASHRAE.
    Retorna el hb_model listo para traducir a IDF.

    NOTA: Esta función es una versión extendida de geometry_utils.py de Streamlit.
    Agrega las propiedades energéticas que faltaban para EnergyPlus.
    """
    from honeybee_energy.programtype import ProgramType
    from honeybee_energy.load.lighting import Lighting
    from honeybee_energy.load.equipment import ElectricEquipment
    from honeybee_energy.load.people import People
    from honeybee_energy.load.infiltration import Infiltration
    from honeybee_energy.load.ventilation import Ventilation
    from honeybee_energy.schedule.ruleset import ScheduleRuleset
    from honeybee_energy.lib.scheduletypelimits import schedule_type_limit_by_identifier
    from honeybee_energy.construction.window import WindowConstruction
    from honeybee_energy.lib.constructions import opaque_construction_by_identifier

    # ---- 1. Geometría base (igual que geometry_utils.py) ----
    puntos_piso = [
        Point3D(0, 0, 0), Point3D(ancho, 0, 0),
        Point3D(ancho, largo, 0), Point3D(0, largo, 0)
    ]
    room_df = Room2D(f"Nave_{identifier_sufijo}", Face3D(puntos_piso),
                     floor_to_ceiling_height=altura)
    story = Story("Nivel_0", room_2ds=[room_df])
    building = Building("Planta_Industrial", unique_stories=[story])
    hb_model = DFModel("Modelo_Nave", buildings=[building]).to_honeybee(
        object_per_model="Building")[0]
    hb_room = hb_model.rooms[0]

    # ---- 2. Inyección de domos en el techo ----
    techo = [f for f in hb_room.faces if f.type.name == "RoofCeiling"][0]
    techo.boundary_condition = Outdoors()

    area_domo = domo_ancho * domo_largo
    area_piso = ancho * largo
    num_domos = max(1, math.ceil((area_piso * sfr) / area_domo))
    cols = max(1, round((num_domos * (ancho / largo)) ** 0.5))
    filas = max(1, math.ceil(num_domos / cols))
    dx, dy = ancho / cols, largo / filas

    contador = 1
    for i in range(cols):
        for j in range(filas):
            cx = (i * dx) + (dx / 2)
            cy = (j * dy) + (dy / 2)
            pt1 = Point3D(cx - domo_ancho/2, cy - domo_largo/2, altura)
            pt2 = Point3D(cx + domo_ancho/2, cy - domo_largo/2, altura)
            pt3 = Point3D(cx + domo_ancho/2, cy + domo_largo/2, altura)
            pt4 = Point3D(cx - domo_ancho/2, cy + domo_largo/2, altura)
            techo.add_aperture(Aperture(f"Domo_{contador}_{identifier_sufijo}",
                                        Face3D([pt1, pt2, pt3, pt4])))
            contador += 1

    sfr_real = ((contador - 1) * area_domo) / area_piso

    # ---- 3. Propiedades Energéticas (ASHRAE 90.1) ----
    # Tablas LPD y cargas internas por tipo de uso
    # Valores de ASHRAE 90.1-2019 Tabla 9.6.1
    PERFILES_ASHRAE = {
        "warehouse": {
            "lpd_w_m2": 6.5,        # W/m² Lighting Power Density
            "equip_w_m2": 4.0,      # W/m² Equipment
            "people_m2_p": 100.0,   # m² por persona
            "infiltracion": 0.0003, # m³/s·m² @ 4Pa
            "vent_l_s_m2": 0.3,     # L/(s·m²) ventilación mínima
        },
        "manufacturing": {
            "lpd_w_m2": 12.0,
            "equip_w_m2": 20.0,
            "people_m2_p": 30.0,
            "infiltracion": 0.0003,
            "vent_l_s_m2": 0.6,
        },
        "office": {
            "lpd_w_m2": 10.8,
            "equip_w_m2": 10.0,
            "people_m2_p": 10.0,
            "infiltracion": 0.0002,
            "vent_l_s_m2": 0.6,
        }
    }

    perfil = PERFILES_ASHRAE.get(tipo_uso, PERFILES_ASHRAE["warehouse"])

    # Horario base laboral: Lun-Vie 7am-6pm
    try:
        fractional = schedule_type_limit_by_identifier("Fractional")
        sched_operacion = ScheduleRuleset.from_constant_value(
            "Horario_Laboral", 1.0, fractional)
        # Agregar horario nocturno (0.05 para infiltraciones nocturnas)
        sched_base = ScheduleRuleset.from_constant_value(
            "Horario_Base", 0.0, fractional)
    except Exception:
        # Si no hay tipos de límite disponibles, usar schedules simples
        sched_operacion = ScheduleRuleset.from_constant_value(
            "Horario_Laboral", 1.0)
        sched_base = ScheduleRuleset.from_constant_value(
            "Horario_Base", 0.0)

    # Iluminación
    lighting = Lighting(
        identifier="Iluminacion_Nave",
        watts_per_area=perfil["lpd_w_m2"],
        schedule=sched_operacion,
        radiant_fraction=0.32,
        visible_fraction=0.25,
        return_air_fraction=0.0
    )

    # Equipos eléctricos
    equipment = ElectricEquipment(
        identifier="Equipos_Electricos",
        watts_per_area=perfil["equip_w_m2"],
        schedule=sched_operacion,
        radiant_fraction=0.5,
        latent_fraction=0.0,
        lost_fraction=0.1
    )

    # Ocupantes
    people = People(
        identifier="Ocupantes",
        people_per_area=1.0 / perfil["people_m2_p"],
        occupancy_schedule=sched_operacion,
        activity_schedule=ScheduleRuleset.from_constant_value("Actividad", 120.0)
    )

    # Infiltración
    infiltration = Infiltration(
        identifier="Infiltracion",
        flow_per_exterior_area=perfil["infiltracion"],
        schedule=sched_operacion
    )

    # Ventilación mínima
    ventilation = Ventilation(
        identifier="Ventilacion",
        flow_per_area=perfil["vent_l_s_m2"] / 1000.0,  # Convertir L/s/m2 a m3/s/m2
        flow_per_person=0.0
    )

    # Crear ProgramType para la nave
    program_type = ProgramType(f"Programa_{tipo_uso}")
    program_type.lighting = lighting
    program_type.electric_equipment = equipment
    program_type.people = people
    program_type.infiltration = infiltration
    program_type.ventilation = ventilation

    # Asignar a la habitación
    hb_room.properties.energy.program_type = program_type

    # ---- 4. HVAC: Ideal Air Loads (EnergyPlus IdealAirSystem) ----
    # Usamos Ideal Air Loads porque es el modelo más robusto para simular
    # la demanda de carga ANTES de especificar el equipo real.
    # Nos da kWh de demanda que luego dividimos por COP para obtener consumo.
    try:
        from honeybee_energy.hvac.idealair import IdealAirSystem
        hvac = IdealAirSystem(
            identifier=f"HVAC_IdealAir_{identifier_sufijo}",
            economizer_type="DifferentialDryBulb",
            demand_controlled_ventilation=False,
            sensible_heat_recovery=0.0,
            latent_heat_recovery=0.0,
            heating_limit=None,   # Sin limite, calcula demanda real
            cooling_limit=None
        )
        hb_room.properties.energy.hvac = hvac
    except Exception as e:
        print(f"   AVISO: HVAC IdealAir no disponible ({e})")

    # ---- 5. Construcciones de la Envolvente ----
    # Usamos las construcciones genéricas de Honeybee que ya existen en requirements.txt
    try:
        # Techo: Membrana con aislamiento (R-10 aprox.)
        techo_constr = opaque_construction_by_identifier("Generic Roof Membrane")
        hb_room.properties.energy.construction_set  # verificar que existe

        # Propiedades del domo (construcción de ventana personalizada)
        from honeybee_energy.material.glazing import EnergyWindowMaterialSimpleGlazSys
        mat_domo = EnergyWindowMaterialSimpleGlazSys(
            identifier=f"Domo_Sunoptics_{identifier_sufijo}",
            u_factor=domo_u,
            shgc=domo_shgc,
            vt=domo_vlt
        )
        constr_domo = WindowConstruction(
            identifier=f"Constr_Domo_{identifier_sufijo}",
            materials=[mat_domo]
        )

        # Asignar la construcción del domo a todas las apertures del techo
        for aperture in techo.apertures:
            aperture.properties.energy.construction = constr_domo

    except Exception as e:
        print(f"   AVISO: Construcciones no disponibles ({e}). Usando defaults LBT.")

    # ---- 6. Parámetros de Simulación ----
    sim_params = SimulationParameter()
    sim_params.output = SimulationOutput(
        include_sqlite=True,
        include_html=False,
        outputs=[
            "Zone Ideal Loads Cooling Energy",
            "Zone Ideal Loads Heating Energy",
            "Zone Lights Electricity Energy",
            "Zone Infiltration Sensible Heat Loss Energy",
            "Zone Infiltration Sensible Heat Gain Energy",
            "Zone People Occupant Count",
            "Site Outdoor Air Drybulb Temperature",
        ],
        reporting_frequency="Hourly"
    )

    return hb_model, sfr_real, sim_params

# ==========================================================
# CELDA 6: SIMULACIÓN CON ENERGYPLUS
# ==========================================================

def ejecutar_simulacion_ep(hb_model, epw_path, sim_params, carpeta_salida, nombre="caso_sfr"):
    """
    Traduce el modelo Honeybee a IDF y ejecuta EnergyPlus.
    Retorna la ruta del archivo .sql con los resultados.
    """
    import json

    carpeta_caso = os.path.join(carpeta_salida, nombre)
    os.makedirs(carpeta_caso, exist_ok=True)

    # 1. Guardar .hbjson
    hbjson_path = os.path.join(carpeta_caso, "modelo.hbjson")
    with open(hbjson_path, "w") as f:
        json.dump(hb_model.to_dict(), f)

    # 2. Guardar parámetros de simulación
    sim_params_path = os.path.join(carpeta_caso, "sim_params.json")
    with open(sim_params_path, "w") as f:
        json.dump(sim_params.to_dict(), f)

    # 3. Traducir a IDF usando honeybee-energy CLI
    idf_path = os.path.join(carpeta_caso, "modelo.idf")

    cmd_translate = [
        "honeybee-energy", "translate", "model-to-idf",
        hbjson_path,
        "--output-file", idf_path,
        "--sim-par-json", sim_params_path
    ]

    result_translate = subprocess.run(cmd_translate, capture_output=True, text=True)

    if not os.path.exists(idf_path):
        # Segundo intento con método alternativo via Python API
        try:
            from honeybee_energy.run import to_idf
            idf_path = to_idf(hbjson_path, sim_par_json=sim_params_path,
                              folder=carpeta_caso)
            print(f"   IDF generado via Python API: {idf_path}")
        except Exception as e:
            raise RuntimeError(
                f"ERROR: Fallo al generar IDF.\n"
                f"CLI stdout: {result_translate.stdout}\n"
                f"CLI stderr: {result_translate.stderr}\n"
                f"Python API error: {e}"
            )
    else:
        print(f"   IDF generado via CLI: {os.path.basename(idf_path)}")

    # 4. Ejecutar EnergyPlus
    # Detectar ruta del ejecutable
    for ep_exec in ["/usr/local/energyplus", "/usr/local/bin/energyplus", "energyplus"]:
        if os.path.exists(ep_exec) or ep_exec == "energyplus":
            break

    cmd_simulate = [
        ep_exec,
        "-w", epw_path,
        "-d", carpeta_caso,
        "-r",           # readvars para CSV adicional
        idf_path
    ]

    print(f"   Ejecutando EnergyPlus para '{nombre}'...")
    result_sim = subprocess.run(cmd_simulate, capture_output=True, text=True, timeout=300)

    sql_path = os.path.join(carpeta_caso, "eplusout.sql")

    if not os.path.exists(sql_path):
        # Buscar en subdirectorios
        for root, _, files in os.walk(carpeta_caso):
            for f in files:
                if f == "eplusout.sql":
                    sql_path = os.path.join(root, f)
                    break

    if not os.path.exists(sql_path):
        raise RuntimeError(
            f"ERROR: EnergyPlus no genero .sql para '{nombre}'.\n"
            f"STDERR: {result_sim.stderr[-2000:]}"
        )

    print(f"   Simulacion exitosa: {sql_path} ({os.path.getsize(sql_path)/1024:.1f} KB)")
    return sql_path

# ==========================================================
# CELDA 7: EXTRACCIÓN DE RESULTADOS DEL SQL
# ==========================================================

def extraer_resultados_sql(sql_path):
    """
    Lee el archivo .sql de EnergyPlus y extrae:
    - Consumo anual de iluminación (kWh)
    - Consumo anual de enfriamiento (kWh de demanda)
    - Consumo anual de calefacción (kWh de demanda)
    - Datos horarios para el heatmap
    Retorna un dict con KPIs y DataFrames.
    """
    conn = sqlite3.connect(sql_path)

    # ---- Diccionario de variables disponibles ----
    df_dict = pd.read_sql_query(
        "SELECT ReportDataDictionaryIndex, Name, Units FROM ReportDataDictionary",
        conn
    )

    def obtener_energia_anual(nombre_variable, unidad="J"):
        """Extrae la suma anual de una variable en kWh."""
        try:
            idx_rows = df_dict[df_dict["Name"].str.contains(nombre_variable, case=False, na=False)]
            if idx_rows.empty:
                return 0.0
            idxs = idx_rows["ReportDataDictionaryIndex"].tolist()
            idx_str = ",".join(map(str, idxs))
            query = f"SELECT SUM(Value) as Total FROM ReportData WHERE ReportDataDictionaryIndex IN ({idx_str})"
            result = pd.read_sql_query(query, conn)
            total_j = result["Total"].iloc[0] or 0.0
            # Convertir J → kWh
            return total_j / 3_600_000.0
        except Exception as e:
            print(f"   AVISO: No se pudo extraer '{nombre_variable}': {e}")
            return 0.0

    def obtener_serie_horaria(nombre_variable):
        """Extrae serie de 8760 horas de una variable."""
        try:
            idx_rows = df_dict[df_dict["Name"].str.contains(nombre_variable, case=False, na=False)]
            if idx_rows.empty:
                return np.zeros(8760)
            idxs = idx_rows["ReportDataDictionaryIndex"].tolist()
            idx_str = ",".join(map(str, idxs))
            query = f"""
                SELECT rd.TimeIndex, SUM(rd.Value) as Value
                FROM ReportData rd
                WHERE rd.ReportDataDictionaryIndex IN ({idx_str})
                GROUP BY rd.TimeIndex
                ORDER BY rd.TimeIndex
            """
            df_serie = pd.read_sql_query(query, conn)
            valores = df_serie["Value"].values
            # Asegurar exactamente 8760 puntos
            if len(valores) >= 8760:
                return valores[:8760]
            else:
                padded = np.zeros(8760)
                padded[:len(valores)] = valores
                return padded
        except Exception as e:
            print(f"   AVISO: Serie horaria '{nombre_variable}' no disponible: {e}")
            return np.zeros(8760)

    # ---- Extracción de KPIs anuales ----
    kwh_luz_anual      = obtener_energia_anual("Lights Electricity Energy")
    kwh_cooling_demand = obtener_energia_anual("Ideal Loads Cooling Energy")
    kwh_heating_demand = obtener_energia_anual("Ideal Loads Heating Energy")

    # ---- Series horarias para visualización ----
    serie_luz      = obtener_serie_horaria("Lights Electricity Energy")
    serie_cooling  = obtener_serie_horaria("Ideal Loads Cooling Energy")
    serie_heating  = obtener_serie_horaria("Ideal Loads Heating Energy")

    conn.close()

    # Nota: Las demandas vienen en J, ya convertidas a kWh en obtener_energia_anual()
    # El consumo real de equipos HVAC = demanda / COP (se aplica fuera de esta función)

    return {
        "kwh_iluminacion":    kwh_luz_anual,
        "kwh_cooling_demand": kwh_cooling_demand,
        "kwh_heating_demand": kwh_heating_demand,
        "serie_iluminacion":  serie_luz / 3_600_000.0,    # J a kWh por hora
        "serie_cooling":      serie_cooling / 3_600_000.0,
        "serie_heating":      serie_heating / 3_600_000.0,
    }

# ==========================================================
# CELDA 8: CURVA DE OPTIMIZACIÓN SFR (SPLIT-FLUX)
# ==========================================================

def simular_curva_sfr(
    ancho, largo, altura,
    epw_path,
    sfr_valores=None,
    tipo_uso="warehouse",
    domo_vlt=0.67, domo_shgc=0.48, domo_u=3.2,
    domo_ancho=1.3279, domo_largo=2.5465,
    cop_cooling=3.5, eff_heating=0.85,
    carpeta_salida="/content/simulaciones_sfr"
):
    """
    FUNCIÓN PRINCIPAL DEL MOTOR TÉRMICO.

    Simula la nave industrial con N valores de SFR (Sky Fraction Ratio),
    ejecutando EnergyPlus para cada caso y extrayendo los kWh reales.

    Retorna un DataFrame con la curva completa de Split-Flux:
    - ahorro_luz_kwh:     Ahorro por reducción de iluminación artificial
    - penalizacion_cooling_kwh: Carga extra de AC por calor solar del domo
    - ahorro_calefaccion_kwh:   Ahorro de calefacción por calor solar del domo
    - ahorro_neto_kwh:    Balance final (lo que maximizamos)

    Compatibilidad: La salida de esta función alimenta directamente
    tab_analitica en app.py de Streamlit.
    """
    if sfr_valores is None:
        sfr_valores = np.arange(0.01, 0.11, 0.01)

    os.makedirs(carpeta_salida, exist_ok=True)

    # --- CASO BASE: SFR = 0 (sin domos) ---
    print("\n" + "="*60)
    print("SIMULANDO CASO BASE (SFR = 0%)...")
    print("="*60)

    # Para SFR=0 usamos SFR mínimo funcional (no se pueden hacer 0 domos en EnergyPlus)
    # pero le ponemos VLT=0 y SHGC=0 para emular "sin domos"
    modelo_base, _, params_base = construir_modelo_hb(
        ancho, largo, altura,
        sfr=0.001,  # 1 domo simbólico
        domo_ancho=domo_ancho, domo_largo=domo_largo,
        tipo_uso=tipo_uso,
        domo_vlt=0.001,   # Opaco: no deja pasar luz
        domo_shgc=0.001,  # Sin ganancia solar
        domo_u=domo_u,
        identifier_sufijo="base"
    )

    sql_base = ejecutar_simulacion_ep(
        modelo_base, epw_path, params_base,
        carpeta_salida, nombre="caso_base"
    )
    resultados_base = extraer_resultados_sql(sql_base)

    kwh_luz_base      = resultados_base["kwh_iluminacion"]
    kwh_cooling_base  = resultados_base["kwh_cooling_demand"] / cop_cooling
    kwh_heating_base  = resultados_base["kwh_heating_demand"] / eff_heating

    print("\nCASO BASE:")
    print(f"   Iluminacion:  {kwh_luz_base:,.0f} kWh/anio")
    print(f"   Cooling:      {kwh_cooling_base:,.0f} kWh/anio")
    print(f"   Heating:      {kwh_heating_base:,.0f} kWh/anio")
    print(f"   TOTAL BASE:   {kwh_luz_base + kwh_cooling_base + kwh_heating_base:,.0f} kWh/anio")

    # --- CASOS SFR ---
    resultados_sfr = []

    for sfr in sfr_valores:
        sfr_pct = sfr * 100
        nombre_caso = f"caso_sfr_{sfr_pct:.0f}pct"
        print(f"\n--- Simulando SFR = {sfr_pct:.0f}% ---")

        try:
            modelo_sfr, sfr_real, params_sfr = construir_modelo_hb(
                ancho, largo, altura, sfr,
                domo_ancho=domo_ancho, domo_largo=domo_largo,
                tipo_uso=tipo_uso,
                domo_vlt=domo_vlt, domo_shgc=domo_shgc, domo_u=domo_u,
                identifier_sufijo=f"sfr{sfr_pct:.0f}"
            )

            sql_sfr = ejecutar_simulacion_ep(
                modelo_sfr, epw_path, params_sfr,
                carpeta_salida, nombre=nombre_caso
            )
            res = extraer_resultados_sql(sql_sfr)

            kwh_luz_sfr      = res["kwh_iluminacion"]
            kwh_cooling_sfr  = res["kwh_cooling_demand"] / cop_cooling
            kwh_heating_sfr  = res["kwh_heating_demand"] / eff_heating

            # ---- CÁLCULO DEL SPLIT-FLUX (Flujo Dividido) ----
            # Exactamente la lógica del VBA: Savings = Base - Design
            ahorro_luz       = kwh_luz_base - kwh_luz_sfr          # + = ahorro
            penalizacion_cool= kwh_cooling_sfr - kwh_cooling_base   # + = más consumo
            ahorro_heat      = kwh_heating_base - kwh_heating_sfr   # + = ahorro
            ahorro_neto      = ahorro_luz - penalizacion_cool + ahorro_heat

            resultado = {
                "sfr_pct":              sfr_pct,
                "sfr_real_pct":         sfr_real * 100,
                "num_domos":            math.ceil((ancho * largo * sfr) / (domo_ancho * domo_largo)),
                # Consumos absolutos
                "kwh_luz_base":         kwh_luz_base,
                "kwh_luz_sfr":          kwh_luz_sfr,
                "kwh_cooling_base":     kwh_cooling_base,
                "kwh_cooling_sfr":      kwh_cooling_sfr,
                "kwh_heating_base":     kwh_heating_base,
                "kwh_heating_sfr":      kwh_heating_sfr,
                # Split-Flux (igual que columnas de Graph_Results en VBA)
                "ahorro_luz_kwh":       ahorro_luz,
                "penalizacion_cool_kwh": penalizacion_cool,
                "ahorro_heat_kwh":      ahorro_heat,
                "ahorro_neto_kwh":      ahorro_neto,
                # Autonomía lumínica (sDA estimada)
                "sda_estimada_pct":     min(100, (sfr_real / 0.04) * 45),  # heurística
            }

            resultados_sfr.append(resultado)

            print(f"   Ahorro luz:    {ahorro_luz:+,.0f} kWh/anio")
            print(f"   Penaliz. AC:  {penalizacion_cool:+,.0f} kWh/anio")
            print(f"   Ahorro heat:  {ahorro_heat:+,.0f} kWh/anio")
            print(f"   Ahorro NETO:  {ahorro_neto:+,.0f} kWh/anio")

        except Exception as e:
            print(f"   ERROR en SFR {sfr_pct:.0f}%: {e}")
            continue

    df_resultados = pd.DataFrame(resultados_sfr)
    return df_resultados, resultados_base

# ==========================================================
# CELDA 9: VISUALIZACIÓN (Gráficos Plotly para Streamlit)
# ==========================================================

def graficar_curva_optimizacion(df_resultados):
    """
    Genera la gráfica interactiva de Split-Flux / Rendimientos Decrecientes.
    Compatible directamente con st.plotly_chart() en Streamlit.
    """
    if df_resultados.empty:
        print("ERROR: No hay datos para graficar.")
        return None

    sfr_optimo = df_resultados.loc[df_resultados["ahorro_neto_kwh"].idxmax(), "sfr_pct"]
    ahorro_max = df_resultados["ahorro_neto_kwh"].max()

    fig = go.Figure()

    # Línea de ahorro en iluminación
    fig.add_trace(go.Scatter(
        x=df_resultados["sfr_pct"],
        y=df_resultados["ahorro_luz_kwh"],
        name="Ahorro Iluminacion",
        line=dict(color="#3498DB", width=2, dash="dash"),
        hovertemplate="SFR %{x:.0f}%: %{y:,.0f} kWh<extra></extra>"
    ))

    # Línea de penalización AC (positivo = más consumo)
    fig.add_trace(go.Scatter(
        x=df_resultados["sfr_pct"],
        y=-df_resultados["penalizacion_cool_kwh"],   # Negativo para mostrar penalización
        name="Penalizacion AC",
        line=dict(color="#E74C3C", width=2),
        hovertemplate="SFR %{x:.0f}%: %{y:,.0f} kWh<extra></extra>"
    ))

    # Ahorro en calefacción
    fig.add_trace(go.Scatter(
        x=df_resultados["sfr_pct"],
        y=df_resultados["ahorro_heat_kwh"],
        name="Ahorro Calefaccion",
        line=dict(color="#F39C12", width=2, dash="dot"),
        hovertemplate="SFR %{x:.0f}%: %{y:,.0f} kWh<extra></extra>"
    ))

    # AHORRO NETO TOTAL (línea principal)
    fig.add_trace(go.Scatter(
        x=df_resultados["sfr_pct"],
        y=df_resultados["ahorro_neto_kwh"],
        name="AHORRO NETO TOTAL",
        line=dict(color="#2ECC71", width=4),
        hovertemplate="SFR %{x:.0f}%: %{y:,.0f} kWh<extra></extra>",
        fill="tozeroy",
        fillcolor="rgba(46, 204, 113, 0.1)"
    ))

    # Línea vertical del SFR óptimo
    fig.add_vline(
        x=sfr_optimo,
        line_width=2,
        line_dash="solid",
        line_color="#8E44AD",
        annotation_text=f"SFR Optimo: {sfr_optimo:.0f}%<br>Ahorro max: {ahorro_max:,.0f} kWh/anio",
        annotation_position="top right",
        annotation_font_color="#8E44AD"
    )

    fig.update_layout(
        title={
            "text": "Curva de Optimizacion Sunoptics (Motor EnergyPlus)",
            "font": {"size": 18}
        },
        xaxis_title="Skylight to Floor Ratio - SFR (%)",
        yaxis_title="Energía Anual (kWh/anio)",
        hovermode="x unified",
        template="plotly_white",
        height=500,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        annotations=[dict(
            x=0.02, y=0.02,
            xref="paper", yref="paper",
            text="<i>Motor: EnergyPlus 23.2 | Datos: TMYx EPW | Honeybee Energy</i>",
            showarrow=False,
            font=dict(size=10, color="gray")
        )]
    )

    fig.show()
    return fig


def graficar_heatmap_ahorro(df_resultados):
    """Tabla de KPIs de ahorro por SFR."""
    if df_resultados.empty:
        return None

    fig = go.Figure(data=[go.Table(
        header=dict(
            values=["SFR %", "# Domos", "Ahorro Luz<br>(kWh)", "Penaliz. AC<br>(kWh)",
                    "Ahorro Heat<br>(kWh)", "<b>AHORRO NETO<br>(kWh)</b>"],
            fill_color="#2C3E50",
            font=dict(color="white", size=12),
            align="center"
        ),
        cells=dict(
            values=[
                df_resultados["sfr_pct"].apply(lambda x: f"{x:.0f}%"),
                df_resultados["num_domos"].astype(int),
                df_resultados["ahorro_luz_kwh"].apply(lambda x: f"{x:,.0f}"),
                df_resultados["penalizacion_cool_kwh"].apply(lambda x: f"{x:,.0f}"),
                df_resultados["ahorro_heat_kwh"].apply(lambda x: f"{x:,.0f}"),
                df_resultados["ahorro_neto_kwh"].apply(lambda x: f"<b>{x:,.0f}</b>"),
            ],
            fill_color=[["#ECF0F1", "#FDFEFE"] * 10],
            font=dict(size=11),
            align="center"
        )
    )])
    fig.update_layout(title="Tabla de Resultados Split-Flux por SFR", height=400)
    fig.show()
    return fig

def main():
    print("SKYCALC 2.0 - MOTOR ENERGYPLUS | ECO CONSULTOR")
    print("=" * 60)

    # 1. Descargar EPW
    try:
        epw_path = descargar_epw_onebuilding(LAT, LON, carpeta_destino="/content")
    except Exception as e:
        print(f"No se pudo descargar EPW automaticamente: {e}")
        print("Usando EPW de prueba (Chicago) para validar el motor...")
        epw_url = "https://raw.githubusercontent.com/ladybug-tools/ladybug/master/tests/epw/chicago.epw"
        epw_path = "/content/test_chicago.epw"
        try:
            urllib.request.urlretrieve(epw_url, epw_path)
        except Exception as e2:
            print(f"Fallo EPW de respaldo tambien: {e2}")
            return None

    print(f"\nEPW listo: {epw_path}\n")

    # 2. Ejecutar curva de optimizacion
    df_resultados, resultados_base = simular_curva_sfr(
        ancho=ANCHO,
        largo=LARGO,
        altura=ALTURA,
        epw_path=epw_path,
        sfr_valores=SFR_VALORES,
        tipo_uso=TIPO_USO,
        domo_vlt=DOMO_VLT,
        domo_shgc=DOMO_SHGC,
        domo_u=DOMO_U,
        domo_ancho=DOMO_ANCHO,
        domo_largo=DOMO_LARGO,
        cop_cooling=COP_COOLING,
        eff_heating=EFF_HEATING,
    )

    if df_resultados is None or df_resultados.empty:
        print("No se obtuvieron resultados. Revisar errores arriba.")
        return None

    # 3. Visualizar
    print("\n" + "=" * 60)
    print("GENERANDO GRAFICOS...")
    print("=" * 60)
    graficar_curva_optimizacion(df_resultados)
    graficar_heatmap_ahorro(df_resultados)

    # 4. Guardar CSV para Streamlit
    csv_path = "/content/resultados_sfr_curva.csv"
    df_resultados.to_csv(csv_path, index=False)
    print(f"\nResultados guardados en: {csv_path}")
    print("Subir este CSV al repositorio de Streamlit para")
    print("visualizacion instantanea sin re-ejecutar EnergyPlus.\n")

    # 5. Resumen ejecutivo
    idx_optimo = df_resultados["ahorro_neto_kwh"].idxmax()
    fila_optima = df_resultados.iloc[idx_optimo]

    print("=" * 60)
    print("RESUMEN EJECUTIVO")
    print("=" * 60)
    print(f"SFR OPTIMO:          {fila_optima['sfr_pct']:.0f}%")
    print(f"DOMOS RECOMENDADOS:  {int(fila_optima['num_domos'])} unidades")
    print(f"Ahorro Iluminacion:  {fila_optima['ahorro_luz_kwh']:,.0f} kWh/anio")
    print(f"Penalizacion AC:    -{fila_optima['penalizacion_cool_kwh']:,.0f} kWh/anio")
    print(f"Ahorro Calefaccion:  {fila_optima['ahorro_heat_kwh']:,.0f} kWh/anio")
    print(f"AHORRO NETO TOTAL:   {fila_optima['ahorro_neto_kwh']:,.0f} kWh/anio")
    print("=" * 60)

    return df_resultados


# EJECUTAR
df = main()
if df is not None:
    print(df[["sfr_pct", "ahorro_luz_kwh", "penalizacion_cool_kwh",
              "ahorro_heat_kwh", "ahorro_neto_kwh"]].to_string(index=False))

# ==========================================================
# CELDA 11: FUNCIÓN EXPORTABLE PARA STREAMLIT
# ==========================================================
# Esta función es la interfaz limpia que se importa desde app.py

def simular_nave_sunoptics(
    ancho, largo, altura,
    domo_vlt, domo_shgc, domo_u, domo_ancho, domo_largo,
    sfr_target,
    epw_path,
    tipo_uso="warehouse",
    cop_cooling=3.5,
    eff_heating=0.85,
):
    """
    INTERFAZ PÚBLICA PARA STREAMLIT.

    Uso en app.py:
        from motor_termico import simular_nave_sunoptics
        resultados = simular_nave_sunoptics(
            ancho=ancho_nave, largo=largo_nave, altura=alto_nave,
            domo_vlt=datos_domo['VLT'], domo_shgc=datos_domo['SHGC'],
            domo_u=datos_domo['U_Value'], domo_ancho=datos_domo['Ancho_m'],
            domo_largo=datos_domo['Largo_m'], sfr_target=sfr_target,
            epw_path=epw_path_from_weather_utils,
        )

    Retorna dict con:
        - df_curva: DataFrame con curva de optimización SFR
        - sfr_optimo: float (%)
        - ahorro_neto_optimo: float (kWh/anio)
        - kwh_luz_base: float
        - fig_curva: figura Plotly
    """
    import tempfile

    carpeta_tmp = tempfile.mkdtemp(prefix="skycalc_sim_")

    sfr_valores = np.arange(0.01, 0.11, 0.01)

    df_curva, resultados_base = simular_curva_sfr(
        ancho=ancho, largo=largo, altura=altura,
        epw_path=epw_path,
        sfr_valores=sfr_valores,
        tipo_uso=tipo_uso,
        domo_vlt=domo_vlt, domo_shgc=domo_shgc, domo_u=domo_u,
        domo_ancho=domo_ancho, domo_largo=domo_largo,
        cop_cooling=cop_cooling, eff_heating=eff_heating,
        carpeta_salida=carpeta_tmp
    )

    if df_curva.empty:
        return None

    idx_optimo = df_curva["ahorro_neto_kwh"].idxmax()
    fila_optima = df_curva.iloc[idx_optimo]
    fig_curva = graficar_curva_optimizacion(df_curva)

    return {
        "df_curva":            df_curva,
        "sfr_optimo_pct":      fila_optima["sfr_pct"],
        "num_domos_optimo":    int(fila_optima["num_domos"]),
        "ahorro_luz_kwh":      fila_optima["ahorro_luz_kwh"],
        "penalizacion_cool_kwh": fila_optima["penalizacion_cool_kwh"],
        "ahorro_heat_kwh":     fila_optima["ahorro_heat_kwh"],
        "ahorro_neto_kwh":     fila_optima["ahorro_neto_kwh"],
        "kwh_luz_base":        resultados_base["kwh_iluminacion"],
        "fig_curva":           fig_curva,
    }

# ==========================================================
# PUNTO DE ENTRADA
# ==========================================================
# EJECUTAR
df = main()
if df is not None:
    print(df[["sfr_pct", "ahorro_luz_kwh", "penalizacion_cool_kwh",
              "ahorro_heat_kwh", "ahorro_neto_kwh"]].to_string(index=False))
