# -*- coding: utf-8 -*-
"""MOTOR TÉRMICO COMPLETO Claude .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q2niLGwTZLYdWMSQdmWWlUZccFzKf2ab

# -*- coding: utf-8 -*-
'''
         SKYCALC 2.0 - MOTOR TÉRMICO COMPLETO (EnergyPlus)          
         Eco Consultor | Sunoptics LATAM                             
         Versión: 3.0 | Para Google Colab (T4 GPU / CPU)

ARQUITECTURA:
  1. Instalación de infraestructura (EnergyPlus + LBT)
  2. Construcción del gemelo digital (Honeybee + Dragonfly)
  3. Asignación de propiedades energéticas ASHRAE (ProgramType + HVAC)
  4. Descarga del archivo climático EPW (OneBuilding / vía weather_utils)
  5. Traducción y ejecución con EnergyPlus
  6. Extraccion de resultados del SQL a DataFrame limpio
  7. Visualización: Curva de optimización SFR (Split-Flux)
  8. Función exportable para integración con app.py de Streamlit

COMPATIBILIDAD: Diseñado para NO romper nada en app.py existente.
El resultado final es la función `simular_nave_sunoptics()` que
puede ser importada directamente desde motor_termico.py en Streamlit.
'''
"""
# ==============================================================
# SKYCALC 2.0 - MOTOR TERMICO ENERGYPLUS
# Eco Consultor | Sunoptics LATAM
#
# INSTRUCCIONES:
#   CELDA 1: Ejecutar sola -> esperar ~5 min -> Runtime > Restart session
#   CELDAS 2-10: Ejecutar en orden. Cada una imprime OK al final.
#   Si una celda NO imprime OK, hay un error. No continuar.
# ==============================================================


# ##############################################################
# CELDA 1 - INSTALACION
# Ejecutar sola. Luego: Runtime > Restart session.
# NO ejecutar de nuevo despues del restart.
# ##############################################################

import subprocess, sys, os

def _pip(pkg):
    subprocess.run([sys.executable, "-m", "pip", "install", "-q", pkg], check=False)

print("Instalando Ladybug Tools...")

pip("pydantic<2.0")
pip("numpy==1.26.4")
pip("ladybug-geometry==1.33.11")
pip("ladybug-core==0.43.18")
pip("honeybee-core==1.60.0")
pip("honeybee-energy==1.109.27")
pip("dragonfly-core==1.57.11")
pip("lbt-dragonfly")
pip("honeybee-openstudio")
pip("setuptools")
pip("pandas matplotlib plotly requests beautifulsoup4 geopy")

print("Instalando EnergyPlus 23.2.0...")

print("CELDA 1: Iniciando instalacion...")
print("  [1/4] pydantic y numpy...")
_pip("pydantic<2.0")
_pip("numpy==1.26.4")

print("  [2/4] Ladybug Tools...")
_pip("ladybug-geometry==1.33.11")
_pip("ladybug-core==0.43.18")
_pip("honeybee-core==1.60.0")
_pip("honeybee-energy==1.109.27")
_pip("dragonfly-core==1.57.11")
_pip("lbt-dragonfly")
_pip("honeybee-openstudio")

print("  [3/4] Librerias de datos y scraping...")
_pip("pandas matplotlib plotly requests beautifulsoup4 geopy")

print("  [4/4] EnergyPlus 23.2.0...")
EP_TAR = "EnergyPlus-23.2.0-7636e6b3e9-Linux-Ubuntu22.04-x86_64.tar.gz"
EP_URL = f"https://github.com/NREL/EnergyPlus/releases/download/v23.2.0/{EP_TAR}"
EP_DIR = EP_TAR.replace(".tar.gz", "")
if not os.path.exists("/usr/local/energyplus"):
    print("  Descargando EnergyPlus (~100MB)...")
    os.system(f"wget -q {EP_URL}")
    os.system(f"tar -xzf {EP_TAR}")
    os.system(f"sudo cp -r {EP_DIR}/. /usr/local/")
    os.system("sudo ln -sf /usr/local/energyplus /usr/local/bin/energyplus 2>/dev/null || true")
else:
    print("  EnergyPlus ya instalado.")

r = subprocess.run(["energyplus", "--version"], capture_output=True, text=True)
ep_ok = "EnergyPlus" in r.stdout
print(f"  EnergyPlus: {'OK - ' + r.stdout.strip() if ep_ok else 'NO ENCONTRADO'}")

print("")
print("=" * 60)
print("CELDA 1 COMPLETA.")
print(">>> SIGUIENTE PASO: Runtime > Restart session <<<")
print("Luego ejecutar celdas 2 a 10 en orden.")
print("=" * 60)


result = subprocess.run(["energyplus", "--version"], capture_output=True, text=True)
if "EnergyPlus" in result.stdout:
    print(f"EnergyPlus listo: {result.stdout.strip()}")
else:
    print("EnergyPlus instalado. Verificar manualmente.")

print("INSTALACION COMPLETA.")
print("Siguiente: Runtime -> Restart session -> ejecuta desde Celda 2.")

# ==========================================================
# CELDA 2: IMPORTACIONES
# ==========================================================

import json
import math
import sqlite3
import shutil
import tempfile
import urllib.request
import zipfile
import warnings
# ##############################################################
# CELDA 2 - IMPORTACIONES GLOBALES
# ##############################################################

import os, sys, math, json, sqlite3, shutil
import tempfile, urllib.request, zipfile
import warnings, subprocess, re, time, random
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
import plotly.graph_objects as go

# Ladybug / Honeybee / Dragonfly
from ladybug_geometry.geometry3d.pointvector import Point3D
from ladybug_geometry.geometry3d.face import Face3D
from dragonfly.model import Model as DFModel
from dragonfly.building import Building
from dragonfly.story import Story
from dragonfly.room2d import Room2D
from honeybee.aperture import Aperture
from honeybee.boundarycondition import Outdoors

# Honeybee Energy (propiedades térmicas)
from honeybee_energy.lib.programtypes import program_type_by_identifier
from honeybee_energy.lib.constructionsets import construction_set_by_identifier
from honeybee_energy.simulation.parameter import SimulationParameter
from honeybee_energy.simulation.output import SimulationOutput
from honeybee_energy.result.loadbalance import LoadBalance

print("OK: Todas las importaciones exitosas.")

# ==========================================================
# CELDA 3: PARÁMETROS DEL PROYECTO (EDITAR AQUÍ)
# ==========================================================

# --- Geometría de la Nave ---
ANCHO       = 50.0    # metros
LARGO       = 100.0   # metros
ALTURA      = 8.0     # metros

# --- Domo Sunoptics (Modelo 4080 DGZ) ---
DOMO_VLT    = 0.67    # Visible Light Transmittance
DOMO_SHGC   = 0.48    # Solar Heat Gain Coefficient
DOMO_U      = 3.20    # W/(m²·K) — Doble acristalamiento
DOMO_ANCHO  = 1.3279  # metros (52.25 in)
DOMO_LARGO  = 2.5465  # metros (100.25 in)

# --- Simulación SFR (para la curva de optimización) ---
# Se simularán estos 10 casos: [1%, 2%, 3%, 4%, 5%, 6%, 7%, 8%, 9%, 10%]
SFR_VALORES = np.arange(0.01, 0.11, 0.01)

# --- Programa de Uso (ASHRAE 90.1) ---
# Opciones verificadas en LBT: "Generic Office Program", "Generic Retail Program"
# Para bodega/industrial usamos parámetros manuales (ver más abajo)
TIPO_USO    = "warehouse"   # "warehouse" | "manufacturing" | "office"

# --- HVAC ---
COP_COOLING  = 3.5   # Coeficiente de rendimiento enfriamiento
EFF_HEATING  = 0.85  # Eficiencia calefacción (gas)
T_COOLING    = 24.0  # grados C setpoint enfriamiento
T_HEATING    = 18.0  # grados C setpoint calefaccion

# --- Ubicación (para EPW) ---
LAT  = 20.5888   # Querétaro, México (cambiar por coordenadas del proyecto)
LON  = -100.3899

print("OK: Parametros configurados correctamente.")

# ==========================================================
# CELDA 4: DESCARGA DEL ARCHIVO EPW
# ==========================================================
# Usa el mismo protocolo de weather_utils.py de Streamlit para
# garantizar compatibilidad. También acepta un path local.

def descargar_epw_onebuilding(lat, lon, carpeta_destino="/content"):
    """
    Localiza y descarga el archivo EPW más cercano desde climate.onebuilding.org
    Retorna la ruta local del archivo .epw descargado.
    Compatible con weather_utils.py de la app Streamlit.
    """
    import requests
    from bs4 import BeautifulSoup
    from geopy.distance import geodesic
    from geopy.geocoders import Photon

    print(f"Buscando estacion EPW para ({lat:.3f}, {lon:.3f})...")

    # 1. Geocodificación inversa → país
    try:
        geolocator = Photon(user_agent="skycalc_colab_v3")
        loc = geolocator.reverse(f"{lat}, {lon}", timeout=10)
        pais_raw = loc.raw.get("properties", {}).get("country", "Mexico")
    except Exception:
        pais_raw = "Mexico"

    print(f"   País detectado: {pais_raw}")

    # 2. Mapeo País → URL OneBuilding (subconjunto del onebuilding_mapping.json)
    MAPEO_PAISES = {
        "mexico":       "https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/MEX_Mexico/",
        "costa rica":   "https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/CRI_Costa_Rica/",
        "colombia":     "https://climate.onebuilding.org/WMO_Region_3_South_America/COL_Colombia/",
        "united states":"https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/USA_United_States_of_America/",
        "spain":        "https://climate.onebuilding.org/WMO_Region_6_Europe/ESP_Spain/",
        "chile":        "https://climate.onebuilding.org/WMO_Region_3_South_America/CHL_Chile/",
        "peru":         "https://climate.onebuilding.org/WMO_Region_3_South_America/PER_Peru/",
        "brazil":       "https://climate.onebuilding.org/WMO_Region_3_South_America/BRA_Brazil/",
        "argentina":    "https://climate.onebuilding.org/WMO_Region_3_South_America/ARG_Argentina/",
    }

    pais_norm = pais_raw.lower().strip()
    url_base = None
    for k, v in MAPEO_PAISES.items():
        if k in pais_norm:
            url_base = v
            break

    if not url_base:
        # Fallback: México
        url_base = MAPEO_PAISES["mexico"]
        print("   AVISO: Pais no mapeado, usando Mexico como fallback.")

    # 3. Scraping sigiloso de la página de OneBuilding
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    }

    try:
        resp = requests.get(url_base, headers=headers, timeout=20)
        soup = BeautifulSoup(resp.text, "html.parser")
        links = [a["href"] for a in soup.find_all("a", href=True)
                 if a["href"].endswith(".zip") and "TMYx" in a["href"]]
    except Exception as e:
        raise RuntimeError(f"Error al acceder a OneBuilding: {e}")

    if not links:
        raise RuntimeError("No se encontraron archivos TMYx en la URL base.")

    # 4. Geocodificar las primeras estaciones y calcular distancia Haversine
    print(f"   Encontradas {len(links)} estaciones. Calculando distancias...")

    def haversine(lat1, lon1, lat2, lon2):
        R = 6371
        dlat = math.radians(lat2 - lat1)
        dlon = math.radians(lon2 - lon1)
        a = (math.sin(dlat/2)**2 +
             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2)
        return R * 2 * math.asin(math.sqrt(a))

    import re, time, random
    mejor_url = None
    mejor_dist = float("inf")
    geolocator2 = Photon(user_agent=f"skycalc_{random.randint(100,999)}")

    for href in links[:20]:  # Revisar las primeras 20 para velocidad
        try:
            # Extraer nombre de ciudad del nombre del archivo
            fname = href.split("/")[-1].replace(".zip", "")
            ciudad_epw = re.sub(r"_TMYx.*", "", fname)
            ciudad_epw = "_".join(ciudad_epw.split("_")[2:]).replace("_", " ").replace(".", " ")

            query = f"{ciudad_epw}, {pais_raw}"
            geo_loc = geolocator2.geocode(query, timeout=5)
            if geo_loc:
                dist = haversine(lat, lon, geo_loc.latitude, geo_loc.longitude)
                if dist < mejor_dist:
                    mejor_dist = dist
                    mejor_url = url_base + href if not href.startswith("http") else href
            time.sleep(0.3)  # Rate limiting para no ser bloqueado
        except Exception:
            continue

    if not mejor_url:
        # Fallback: primera estación disponible
        mejor_url = url_base + links[0]
        mejor_dist = 9999

    print(f"   Estacion seleccionada ({mejor_dist:.1f} km): {mejor_url.split('/')[-1]}")

    # 5. Descargar y extraer el .epw
    zip_path = os.path.join(carpeta_destino, "clima_epw.zip")
    req = urllib.request.Request(mejor_url, headers=headers)
    with urllib.request.urlopen(req) as response:
        with open(zip_path, "wb") as f:
            shutil.copyfileobj(response, f)

    epw_path = None
    with zipfile.ZipFile(zip_path, "r") as z:
        z.extractall(carpeta_destino)
        for fname in z.namelist():
            if fname.endswith(".epw"):
                epw_path = os.path.join(carpeta_destino, fname)
                break

    if not epw_path:
        raise RuntimeError("No se encontró archivo .epw dentro del ZIP.")

    print(f"   EPW listo en: {epw_path}")
    return epw_path

# ==========================================================
# CELDA 5: CONSTRUCTOR DEL MODELO HONEYBEE
# ==========================================================

def construir_modelo_hb(ancho, largo, altura, sfr, domo_ancho, domo_largo,
                        tipo_uso="warehouse", domo_vlt=0.67, domo_shgc=0.48, domo_u=3.2,
                        identifier_sufijo=""):
    """
    Construye un modelo Honeybee completo con propiedades energéticas ASHRAE.
    Retorna el hb_model listo para traducir a IDF.

    NOTA: Esta función es una versión extendida de geometry_utils.py de Streamlit.
    Agrega las propiedades energéticas que faltaban para EnergyPlus.
    """
print("=" * 60)
print("CELDA 2 OK - Importaciones exitosas.")
print("=" * 60)


# ##############################################################
# CELDA 3 - PARAMETROS DEL PROYECTO (editar aqui)
# ##############################################################

# Geometria de la nave
ANCHO  = 50.0    # metros
LARGO  = 100.0   # metros
ALTURA = 8.0     # metros

# Domo Sunoptics modelo 4080 DGZ
DOMO_VLT   = 0.67    # Visible Light Transmittance
DOMO_SHGC  = 0.48    # Solar Heat Gain Coefficient
DOMO_U     = 3.20    # W/(m2 K)
DOMO_ANCHO = 1.3279  # metros
DOMO_LARGO = 2.5465  # metros

# Curva SFR: simular del 1% al 10%
SFR_VALORES = np.arange(0.01, 0.11, 0.01)

# Tipo de uso: "warehouse" | "manufacturing" | "office"
TIPO_USO = "warehouse"

# HVAC
COP_COOLING = 3.5
EFF_HEATING = 0.85

# Coordenadas del proyecto (Queretaro por defecto)
LAT = 20.5888
LON = -100.3899

print("=" * 60)
print("CELDA 3 OK - Parametros cargados:")
print(f"  Nave    : {ANCHO}m x {LARGO}m x {ALTURA}m")
print(f"  Domo    : VLT={DOMO_VLT} | SHGC={DOMO_SHGC} | U={DOMO_U} W/m2K")
print(f"  Uso     : {TIPO_USO}")
print(f"  HVAC    : COP cooling={COP_COOLING} | Eff heating={EFF_HEATING}")
print(f"  Coords  : lat={LAT} lon={LON}")
print(f"  SFR     : {[round(s*100) for s in SFR_VALORES]}%")
print("=" * 60)


# ##############################################################
# CELDA 4 - DESCARGA EPW
# ##############################################################

def descargar_epw_onebuilding(lat, lon, carpeta_destino="/content"):
    """Descarga el EPW mas cercano. Autosuficiente: imports internos."""
    import os, math, shutil, urllib.request, zipfile, re, time, random
    import requests
    from bs4 import BeautifulSoup
    from geopy.geocoders import Photon

    print(f"  Buscando EPW para ({lat:.3f}, {lon:.3f})...")

    try:
        geo = Photon(user_agent="skycalc_v4")
        loc = geo.reverse(f"{lat}, {lon}", timeout=10)
        pais_raw = loc.raw.get("properties", {}).get("country", "Mexico")
    except Exception:
        pais_raw = "Mexico"
    print(f"  Pais detectado: {pais_raw}")

    MAPEO = {
        "mexico":        "https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/MEX_Mexico/",
        "costa rica":    "https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/CRI_Costa_Rica/",
        "colombia":      "https://climate.onebuilding.org/WMO_Region_3_South_America/COL_Colombia/",
        "united states": "https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/USA_United_States_of_America/",
        "spain":         "https://climate.onebuilding.org/WMO_Region_6_Europe/ESP_Spain/",
        "chile":         "https://climate.onebuilding.org/WMO_Region_3_South_America/CHL_Chile/",
        "brazil":        "https://climate.onebuilding.org/WMO_Region_3_South_America/BRA_Brazil/",
        "argentina":     "https://climate.onebuilding.org/WMO_Region_3_South_America/ARG_Argentina/",
        "peru":          "https://climate.onebuilding.org/WMO_Region_3_South_America/PER_Peru/",
    }
    url_base = next((v for k, v in MAPEO.items() if k in pais_raw.lower()), MAPEO["mexico"])

    headers = {"User-Agent": "Mozilla/5.0"}
    resp  = requests.get(url_base, headers=headers, timeout=20)
    soup  = BeautifulSoup(resp.text, "html.parser")
    links = [a["href"] for a in soup.find_all("a", href=True)
             if a["href"].endswith(".zip") and "TMYx" in a["href"]]
    if not links:
        raise RuntimeError("No se encontraron archivos TMYx.")
    print(f"  {len(links)} estaciones encontradas. Calculando distancias...")

    def haversine(la1, lo1, la2, lo2):
        R = 6371
        dla = math.radians(la2 - la1); dlo = math.radians(lo2 - lo1)
        a = math.sin(dla/2)**2 + math.cos(math.radians(la1)) * math.cos(math.radians(la2)) * math.sin(dlo/2)**2
        return R * 2 * math.asin(math.sqrt(a))

    geo2 = Photon(user_agent=f"skycalc_{random.randint(100,999)}")
    mejor_url, mejor_dist = None, float("inf")
    for href in links[:20]:
        try:
            fname  = href.split("/")[-1].replace(".zip", "")
            ciudad = re.sub(r"_TMYx.*", "", fname)
            ciudad = "_".join(ciudad.split("_")[2:]).replace("_", " ").replace(".", " ")
            gloc   = geo2.geocode(f"{ciudad}, {pais_raw}", timeout=5)
            if gloc:
                d = haversine(lat, lon, gloc.latitude, gloc.longitude)
                if d < mejor_dist:
                    mejor_dist = d
                    mejor_url  = (url_base + href) if not href.startswith("http") else href
            time.sleep(0.3)
        except Exception:
            continue

    if not mejor_url:
        mejor_url  = (url_base + links[0]) if not links[0].startswith("http") else links[0]
        mejor_dist = 9999

    print(f"  Estacion seleccionada ({mejor_dist:.0f} km): {mejor_url.split('/')[-1]}")

    zip_path = os.path.join(carpeta_destino, "clima_epw.zip")
    req = urllib.request.Request(mejor_url, headers=headers)
    with urllib.request.urlopen(req) as r:
        with open(zip_path, "wb") as f:
            shutil.copyfileobj(r, f)

    epw_path = None
    with zipfile.ZipFile(zip_path, "r") as z:
        z.extractall(carpeta_destino)
        for fname in z.namelist():
            if fname.endswith(".epw"):
                epw_path = os.path.join(carpeta_destino, fname)
                break

    if not epw_path:
        raise RuntimeError("No se encontro .epw en el ZIP.")
    return epw_path


# --- Ejecutar descarga ---
print("CELDA 4: Descargando EPW...")
try:
    epw_path = descargar_epw_onebuilding(lat=LAT, lon=LON)
    print("=" * 60)
    print(f"CELDA 4 OK - EPW listo:")
    print(f"  {epw_path}")
    print("=" * 60)
except Exception as _e4:
    print(f"  AVISO: Fallo descarga automatica ({_e4})")
    print("  Usando EPW de Chicago para pruebas...")
    _url_fb = "https://raw.githubusercontent.com/ladybug-tools/ladybug/master/tests/epw/chicago.epw"
    epw_path = "/content/chicago_test.epw"
    urllib.request.urlretrieve(_url_fb, epw_path)
    print("=" * 60)
    print(f"CELDA 4 OK (fallback) - EPW listo:")
    print(f"  {epw_path}")
    print("=" * 60)


# ##############################################################
# CELDA 5 - CONSTRUCTOR DEL MODELO HONEYBEE
# ##############################################################

def construir_modelo_hb(ancho, largo, altura, sfr,
                         domo_ancho, domo_largo,
                         tipo_uso="warehouse",
                         domo_vlt=0.67, domo_shgc=0.48, domo_u=3.2,
                         identifier_sufijo=""):
    """Construye modelo Honeybee con ASHRAE. Autosuficiente: imports internos."""
    import os, math
    from ladybug_geometry.geometry3d.pointvector import Point3D
    from ladybug_geometry.geometry3d.face import Face3D
    from dragonfly.model import Model as DFModel
    from dragonfly.building import Building
    from dragonfly.story import Story
    from dragonfly.room2d import Room2D
    from honeybee.aperture import Aperture
    from honeybee.boundarycondition import Outdoors
    from honeybee_energy.programtype import ProgramType
    from honeybee_energy.load.lighting import Lighting
    from honeybee_energy.load.equipment import ElectricEquipment
    from honeybee_energy.load.people import People
    from honeybee_energy.load.infiltration import Infiltration
    from honeybee_energy.load.ventilation import Ventilation
    from honeybee_energy.schedule.ruleset import ScheduleRuleset
    from honeybee_energy.lib.scheduletypelimits import schedule_type_limit_by_identifier
    # from honeybee_energy.facetype import face_types
    # from honeybee_energy.modifier.modifierbase import ModifierBase
    from honeybee_energy.construction.opaque import OpaqueConstruction
    from honeybee_energy.construction.window import WindowConstruction
    from honeybee_energy.lib.constructions import opaque_construction_by_identifier
    from honeybee_energy.lib.constructions import window_construction_by_identifier

    # ---- 1. Geometría base (igual que geometry_utils.py) ----
    puntos_piso = [
        Point3D(0, 0, 0), Point3D(ancho, 0, 0),
        Point3D(ancho, largo, 0), Point3D(0, largo, 0)
    ]
    room_df = Room2D(f"Nave_{identifier_sufijo}", Face3D(puntos_piso),
                     floor_to_ceiling_height=altura)
    story = Story("Nivel_0", room_2ds=[room_df])
    building = Building("Planta_Industrial", unique_stories=[story])
    hb_model = DFModel("Modelo_Nave", buildings=[building]).to_honeybee(
        object_per_model="Building")[0]
    hb_room = hb_model.rooms[0]

    # ---- 2. Inyección de domos en el techo ----
    techo = [f for f in hb_room.faces if f.type.name == "RoofCeiling"][0]
    techo.boundary_condition = Outdoors()

    area_domo = domo_ancho * domo_largo
    area_piso = ancho * largo
    num_domos = max(1, math.ceil((area_piso * sfr) / area_domo))
    cols = max(1, round((num_domos * (ancho / largo)) ** 0.5))
    filas = max(1, math.ceil(num_domos / cols))
    dx, dy = ancho / cols, largo / filas

    contador = 1
    for i in range(cols):
        for j in range(filas):
            cx = (i * dx) + (dx / 2)
            cy = (j * dy) + (dy / 2)
            pt1 = Point3D(cx - domo_ancho/2, cy - domo_largo/2, altura)
            pt2 = Point3D(cx + domo_ancho/2, cy - domo_largo/2, altura)
            pt3 = Point3D(cx + domo_ancho/2, cy + domo_largo/2, altura)
            pt4 = Point3D(cx - domo_ancho/2, cy + domo_largo/2, altura)
            techo.add_aperture(Aperture(f"Domo_{contador}_{identifier_sufijo}",
                                        Face3D([pt1, pt2, pt3, pt4])))
            contador += 1

    sfr_real = ((contador - 1) * area_domo) / area_piso

    # ---- 3. Propiedades Energéticas (ASHRAE 90.1) ----
    # Tablas LPD y cargas internas por tipo de uso
    # Valores de ASHRAE 90.1-2019 Tabla 9.6.1
    PERFILES_ASHRAE = {
        "warehouse": {
            "lpd_w_m2": 6.5,        # W/m² Lighting Power Density
            "equip_w_m2": 4.0,      # W/m² Equipment
            "people_m2_p": 100.0,   # m² por persona
            "infiltracion": 0.0003, # m³/s·m² @ 4Pa
            "vent_l_s_m2": 0.3,     # L/(s·m²) ventilación mínima
        },
        "manufacturing": {
            "lpd_w_m2": 12.0,
            "equip_w_m2": 20.0,
            "people_m2_p": 30.0,
            "infiltracion": 0.0003,
            "vent_l_s_m2": 0.6,
        },
        "office": {
            "lpd_w_m2": 10.8,
            "equip_w_m2": 10.0,
            "people_m2_p": 10.0,
            "infiltracion": 0.0002,
            "vent_l_s_m2": 0.6,
        }
    }

    perfil = PERFILES_ASHRAE.get(tipo_uso, PERFILES_ASHRAE["warehouse"])

    # Horario base laboral: Lun-Vie 7am-6pm
    try:
        fractional = schedule_type_limit_by_identifier("Fractional")
        sched_operacion = ScheduleRuleset.from_constant_value(
            "Horario_Laboral", 1.0, fractional)
        # Agregar horario nocturno (0.05 para infiltraciones nocturnas)
        sched_base = ScheduleRuleset.from_constant_value(
            "Horario_Base", 0.0, fractional)
    except Exception:
        # Si no hay tipos de límite disponibles, usar schedules simples
        sched_operacion = ScheduleRuleset.from_constant_value(
            "Horario_Laboral", 1.0)
        sched_base = ScheduleRuleset.from_constant_value(
            "Horario_Base", 0.0)

    # Iluminación
    lighting = Lighting(
        identifier="Iluminacion_Nave",
        watts_per_area=perfil["lpd_w_m2"],
        schedule=sched_operacion,
        radiant_fraction=0.32,
        visible_fraction=0.25,
        return_air_fraction=0.0
    )

    # Equipos eléctricos
    equipment = ElectricEquipment(
        identifier="Equipos_Electricos",
        watts_per_area=perfil["equip_w_m2"],
        schedule=sched_operacion,
        radiant_fraction=0.5,
        latent_fraction=0.0,
        lost_fraction=0.1
    )

    # Ocupantes
    people = People(
        identifier="Ocupantes",
        people_per_area=1.0 / perfil["people_m2_p"],
        occupancy_schedule=sched_operacion,
        activity_schedule=ScheduleRuleset.from_constant_value("Actividad", 120.0)
    )

    # Infiltración
    infiltration = Infiltration(
        identifier="Infiltracion",
        flow_per_exterior_area=perfil["infiltracion"],
        schedule=sched_operacion
    )

    # Ventilación mínima
    ventilation = Ventilation(
        identifier="Ventilacion",
        flow_per_area=perfil["vent_l_s_m2"] / 1000.0,  # Convertir L/s/m2 a m3/s/m2
        flow_per_person=0.0
    )

    # Crear ProgramType para la nave
    program_type = ProgramType(f"Programa_{tipo_uso}")
    program_type.lighting = lighting
    program_type.electric_equipment = equipment
    program_type.people = people
    program_type.infiltration = infiltration
    program_type.ventilation = ventilation

    # Asignar a la habitación
    hb_room.properties.energy.program_type = program_type

    # ---- 4. HVAC: Ideal Air Loads (EnergyPlus IdealAirSystem) ----
    # Usamos Ideal Air Loads porque es el modelo más robusto para simular
    # la demanda de carga ANTES de especificar el equipo real.
    # Nos da kWh de demanda que luego dividimos por COP para obtener consumo.
    try:
        from honeybee_energy.hvac.idealair import IdealAirSystem
        hvac = IdealAirSystem(
            identifier=f"HVAC_IdealAir_{identifier_sufijo}",
            economizer_type="DifferentialDryBulb",
            demand_controlled_ventilation=False,
            sensible_heat_recovery=0.0,
            latent_heat_recovery=0.0,
            heating_limit=None,   # Sin limite, calcula demanda real
            cooling_limit=None
        )
        hb_room.properties.energy.hvac = hvac
    except Exception as e:
        print(f"   AVISO: HVAC IdealAir no disponible ({e})")

    # ---- 5. Construcciones de la Envolvente ----
    # Usamos las construcciones genéricas de Honeybee que ya existen en requirements.txt
    from honeybee_energy.simulation.parameter import SimulationParameter
    from honeybee_energy.simulation.output import SimulationOutput

    # 1. Geometria
    pts = [Point3D(0,0,0), Point3D(ancho,0,0),
           Point3D(ancho,largo,0), Point3D(0,largo,0)]
    room_df  = Room2D(f"Nave_{identifier_sufijo}", Face3D(pts),
                      floor_to_ceiling_height=altura)
    story    = Story("Nivel_0", room_2ds=[room_df])
    building = Building("Planta_Industrial", unique_stories=[story])
    hb_model = DFModel("Modelo_Nave", buildings=[building]).to_honeybee(
                   object_per_model="Building")[0]
    hb_room  = hb_model.rooms[0]

    # 2. Domos en el techo
    techo = [f for f in hb_room.faces if f.type.name == "RoofCeiling"][0]
    techo.boundary_condition = Outdoors()
    area_domo = domo_ancho * domo_largo
    area_piso = ancho * largo
    num_domos = max(1, math.ceil((area_piso * sfr) / area_domo))
    cols  = max(1, round((num_domos * (ancho / largo)) ** 0.5))
    filas = max(1, math.ceil(num_domos / cols))
    dx, dy = ancho / cols, largo / filas
    cnt = 1
    for i in range(cols):
        for j in range(filas):
            cx, cy = (i * dx) + dx/2, (j * dy) + dy/2
            techo.add_aperture(Aperture(
                f"Domo_{cnt}_{identifier_sufijo}",
                Face3D([Point3D(cx-domo_ancho/2, cy-domo_largo/2, altura),
                        Point3D(cx+domo_ancho/2, cy-domo_largo/2, altura),
                        Point3D(cx+domo_ancho/2, cy+domo_largo/2, altura),
                        Point3D(cx-domo_ancho/2, cy+domo_largo/2, altura)])))
            cnt += 1
    sfr_real = ((cnt - 1) * area_domo) / area_piso

    # 3. Cargas ASHRAE 90.1
    PERFILES = {
        "warehouse":     {"lpd": 6.5,  "eq": 4.0,  "m2p": 100.0, "inf": 0.0003, "vent": 0.3},
        "manufacturing": {"lpd": 12.0, "eq": 20.0, "m2p": 30.0,  "inf": 0.0003, "vent": 0.6},
        "office":        {"lpd": 10.8, "eq": 10.0, "m2p": 10.0,  "inf": 0.0002, "vent": 0.6},
    }
    p = PERFILES.get(tipo_uso, PERFILES["warehouse"])

    try:
        frac = schedule_type_limit_by_identifier("Fractional")
        s_on = ScheduleRuleset.from_constant_value(f"On_{identifier_sufijo}",  1.0, frac)
    except Exception:
        s_on = ScheduleRuleset.from_constant_value(f"On_{identifier_sufijo}",  1.0)

    prog = ProgramType(f"Prog_{tipo_uso}_{identifier_sufijo}")
    prog.lighting = Lighting(
        f"Luz_{identifier_sufijo}", p["lpd"], s_on,
        radiant_fraction=0.32, visible_fraction=0.25, return_air_fraction=0.0)
    prog.electric_equipment = ElectricEquipment(
        f"Eq_{identifier_sufijo}", p["eq"], s_on,
        radiant_fraction=0.5, latent_fraction=0.0, lost_fraction=0.1)
    try:
        s_act = ScheduleRuleset.from_constant_value(f"Act_{identifier_sufijo}", 120.0)
    except Exception:
        s_act = s_on
    prog.people = People(
        f"Ppl_{identifier_sufijo}", 1.0/p["m2p"], s_on, activity_schedule=s_act)
    prog.infiltration = Infiltration(
        f"Inf_{identifier_sufijo}", p["inf"], s_on)
    prog.ventilation = Ventilation(
        f"Vent_{identifier_sufijo}", flow_per_area=p["vent"]/1000.0, flow_per_person=0.0)
    hb_room.properties.energy.program_type = prog

    # 4. HVAC Ideal Air Loads
    try:
        from honeybee_energy.hvac.idealair import IdealAirSystem
        hvac = IdealAirSystem(
            identifier=f"HVAC_{identifier_sufijo}",
            economizer_type="DifferentialDryBulb",
            demand_controlled_ventilation=False,
            sensible_heat_recovery=0.0, latent_heat_recovery=0.0,
            heating_limit=None, cooling_limit=None)
        hb_room.properties.energy.hvac = hvac
    except Exception as e:
        print(f"    AVISO HVAC: {e}")

    # 5. Material del domo
    try:
        # Techo: Membrana con aislamiento (R-10 aprox.)
        techo_constr = opaque_construction_by_identifier("Generic Roof Membrane")
        hb_room.properties.energy.construction_set  # verificar que existe

        # Propiedades del domo (construcción de ventana personalizada)
        from honeybee_energy.material.glazing import EnergyWindowMaterialSimpleGlazSys
        mat_domo = EnergyWindowMaterialSimpleGlazSys(
            identifier=f"Domo_Sunoptics_{identifier_sufijo}",
            u_factor=domo_u,
            shgc=domo_shgc,
            vt=domo_vlt
        )
        constr_domo = WindowConstruction(
            identifier=f"Constr_Domo_{identifier_sufijo}",
            materials=[mat_domo]
        )

        # Asignar la construcción del domo a todas las apertures del techo
        for aperture in techo.apertures:
            aperture.properties.energy.construction = constr_domo

    except Exception as e:
        print(f"   AVISO: Construcciones no disponibles ({e}). Usando defaults LBT.")

    # ---- 6. Parámetros de Simulación ----
    sim_params = SimulationParameter()
    sim_params.output = SimulationOutput(
        include_sqlite=True,
        include_html=False,
        outputs=[
            "Zone Ideal Loads Cooling Energy",
            "Zone Ideal Loads Heating Energy",
            "Zone Lights Electricity Energy",
            "Zone Infiltration Sensible Heat Loss Energy",
            "Zone Infiltration Sensible Heat Gain Energy",
            "Zone People Occupant Count",
            "Site Outdoor Air Drybulb Temperature",
        ],
        reporting_frequency="Hourly"
    )

    return hb_model, sfr_real, sim_params

# ==========================================================
# CELDA 6: SIMULACIÓN CON ENERGYPLUS
# ==========================================================

def ejecutar_simulacion_ep(hb_model, epw_path, sim_params, carpeta_salida, nombre="caso_sfr"):
    """
    Traduce el modelo Honeybee a IDF y ejecuta EnergyPlus.
    Retorna la ruta del archivo .sql con los resultados.
    """
    import json
        mat = EnergyWindowMaterialSimpleGlazSys(
            f"Mat_{identifier_sufijo}", u_factor=domo_u, shgc=domo_shgc, vt=domo_vlt)
        constr = WindowConstruction(f"Win_{identifier_sufijo}", [mat])
        for ap in techo.apertures:
            ap.properties.energy.construction = constr
    except Exception as e:
        print(f"    AVISO material domo: {e}")

    # 6. Outputs de simulacion
    sim_params = SimulationParameter()
    sim_params.output = SimulationOutput(
        include_sqlite=True, include_html=False,
        outputs=["Zone Ideal Loads Cooling Energy",
                 "Zone Ideal Loads Heating Energy",
                 "Zone Lights Electricity Energy"],
        reporting_frequency="Hourly")

    return hb_model, sfr_real, sim_params


# --- Test de la funcion ---
print("CELDA 5: Probando construir_modelo_hb (SFR=4%)...")
try:
    _m, _sfr_r, _ = construir_modelo_hb(
        ANCHO, LARGO, ALTURA, 0.04,
        DOMO_ANCHO, DOMO_LARGO, TIPO_USO,
        DOMO_VLT, DOMO_SHGC, DOMO_U, "test")
    print(f"  Habitaciones: {len(_m.rooms)}")
    print(f"  SFR real    : {_sfr_r*100:.2f}%")
    print(f"  Area domos  : {_sfr_r * ANCHO * LARGO:.1f} m2")
    del _m
    print("=" * 60)
    print("CELDA 5 OK - construir_modelo_hb() funciona.")
    print("=" * 60)
except Exception as e:
    print(f"CELDA 5 ERROR: {e}")
    raise


# ##############################################################
# CELDA 6 - SIMULACION CON ENERGYPLUS
# ##############################################################

def ejecutar_simulacion_ep(hb_model, epw_path, sim_params,
                            carpeta_salida, nombre="caso"):
    """Traduce a IDF y corre EnergyPlus. Autosuficiente: imports internos."""
    import os, json, subprocess

    carpeta_caso = os.path.join(carpeta_salida, nombre)
    os.makedirs(carpeta_caso, exist_ok=True)

    # 1. Guardar .hbjson
    # Guardar hbjson
    hbjson_path = os.path.join(carpeta_caso, "modelo.hbjson")
    with open(hbjson_path, "w") as f:
        json.dump(hb_model.to_dict(), f)

    # 2. Guardar parámetros de simulación
    sim_params_path = os.path.join(carpeta_caso, "sim_params.json")
    with open(sim_params_path, "w") as f:
        json.dump(sim_params.to_dict(), f)

    # 3. Traducir a IDF usando honeybee-energy CLI
    idf_path = os.path.join(carpeta_caso, "modelo.idf")

    cmd_translate = [
        "honeybee-energy", "translate", "model-to-idf",
        hbjson_path,
        "--output-file", idf_path,
        "--sim-par-json", sim_params_path
    ]

    result_translate = subprocess.run(cmd_translate, capture_output=True, text=True)

    if not os.path.exists(idf_path):
        # Segundo intento con método alternativo via Python API
        try:
            from honeybee_energy.run import to_idf
            idf_path = to_idf(hbjson_path, sim_par_json=sim_params_path,
                              folder=carpeta_caso)
            print(f"   IDF generado via Python API: {idf_path}")
        except Exception as e:
            raise RuntimeError(
                f"ERROR: Fallo al generar IDF.\n"
                f"CLI stdout: {result_translate.stdout}\n"
                f"CLI stderr: {result_translate.stderr}\n"
                f"Python API error: {e}"
            )
    else:
        print(f"   IDF generado via CLI: {os.path.basename(idf_path)}")

    # 4. Ejecutar EnergyPlus
    # Detectar ruta del ejecutable
    for ep_exec in ["/usr/local/energyplus", "/usr/local/bin/energyplus", "energyplus"]:
        if os.path.exists(ep_exec) or ep_exec == "energyplus":
            break

    cmd_simulate = [
        ep_exec,
        "-w", epw_path,
        "-d", carpeta_caso,
        "-r",           # readvars para CSV adicional
        idf_path
    ]

    print(f"   Ejecutando EnergyPlus para '{nombre}'...")
    result_sim = subprocess.run(cmd_simulate, capture_output=True, text=True, timeout=300)

    sql_path = os.path.join(carpeta_caso, "eplusout.sql")

    if not os.path.exists(sql_path):
        # Buscar en subdirectorios
        for root, _, files in os.walk(carpeta_caso):
            for f in files:
                if f == "eplusout.sql":
                    sql_path = os.path.join(root, f)
    # Guardar sim_params
    sp_path = os.path.join(carpeta_caso, "sim_params.json")
    with open(sp_path, "w") as f:
        json.dump(sim_params.to_dict(), f)

    # Traducir a IDF
    idf_path = os.path.join(carpeta_caso, "modelo.idf")
    r_tr = subprocess.run(
        ["honeybee-energy", "translate", "model-to-idf",
         hbjson_path, "--output-file", idf_path, "--sim-par-json", sp_path],
        capture_output=True, text=True)

    if not os.path.exists(idf_path):
        try:
            from honeybee_energy.run import to_idf
            idf_path = to_idf(hbjson_path, sim_par_json=sp_path, folder=carpeta_caso)
            print(f"    IDF via Python API: OK")
        except Exception as e:
            raise RuntimeError(
                f"Fallo IDF.\nCLI: {r_tr.stderr[-500:]}\nAPI: {e}")
    else:
        print(f"    IDF via CLI: OK ({os.path.basename(idf_path)})")

    # Detectar EnergyPlus
    ep = "energyplus"
    for ruta in ["/usr/local/energyplus", "/usr/local/bin/energyplus"]:
        if os.path.exists(ruta):
            ep = ruta
            break

    # Ejecutar
    print(f"    Corriendo EnergyPlus para '{nombre}'...")
    r_sim = subprocess.run(
        [ep, "-w", epw_path, "-d", carpeta_caso, idf_path],
        capture_output=True, text=True, timeout=300)

    # Buscar .sql
    sql_path = os.path.join(carpeta_caso, "eplusout.sql")
    if not os.path.exists(sql_path):
        for root, _, files in os.walk(carpeta_caso):
            for fn in files:
                if fn == "eplusout.sql":
                    sql_path = os.path.join(root, fn)
                    break

    if not os.path.exists(sql_path):
        raise RuntimeError(
            f"ERROR: EnergyPlus no genero .sql para '{nombre}'.\n"
            f"STDERR: {result_sim.stderr[-2000:]}"
        )

    print(f"   Simulacion exitosa: {sql_path} ({os.path.getsize(sql_path)/1024:.1f} KB)")
    return sql_path

# ==========================================================
# CELDA 7: EXTRACCIÓN DE RESULTADOS DEL SQL
# ==========================================================

def extraer_resultados_sql(sql_path):
    """
    Lee el archivo .sql de EnergyPlus y extrae:
    - Consumo anual de iluminación (kWh)
    - Consumo anual de enfriamiento (kWh de demanda)
    - Consumo anual de calefacción (kWh de demanda)
    - Datos horarios para el heatmap
    Retorna un dict con KPIs y DataFrames.
    """
    conn = sqlite3.connect(sql_path)

    # ---- Diccionario de variables disponibles ----
    df_dict = pd.read_sql_query(
        "SELECT ReportDataDictionaryIndex, Name, Units FROM ReportDataDictionary",
        conn
    )

    def obtener_energia_anual(nombre_variable, unidad="J"):
        """Extrae la suma anual de una variable en kWh."""
        try:
            idx_rows = df_dict[df_dict["Name"].str.contains(nombre_variable, case=False, na=False)]
            if idx_rows.empty:
                return 0.0
            idxs = idx_rows["ReportDataDictionaryIndex"].tolist()
            idx_str = ",".join(map(str, idxs))
            query = f"SELECT SUM(Value) as Total FROM ReportData WHERE ReportDataDictionaryIndex IN ({idx_str})"
            result = pd.read_sql_query(query, conn)
            total_j = result["Total"].iloc[0] or 0.0
            # Convertir J → kWh
            return total_j / 3_600_000.0
        except Exception as e:
            print(f"   AVISO: No se pudo extraer '{nombre_variable}': {e}")
            return 0.0

    def obtener_serie_horaria(nombre_variable):
        """Extrae serie de 8760 horas de una variable."""
        try:
            idx_rows = df_dict[df_dict["Name"].str.contains(nombre_variable, case=False, na=False)]
            if idx_rows.empty:
                return np.zeros(8760)
            idxs = idx_rows["ReportDataDictionaryIndex"].tolist()
            idx_str = ",".join(map(str, idxs))
            query = f"""
                SELECT rd.TimeIndex, SUM(rd.Value) as Value
                FROM ReportData rd
                WHERE rd.ReportDataDictionaryIndex IN ({idx_str})
                GROUP BY rd.TimeIndex
                ORDER BY rd.TimeIndex
            """
            df_serie = pd.read_sql_query(query, conn)
            valores = df_serie["Value"].values
            # Asegurar exactamente 8760 puntos
            if len(valores) >= 8760:
                return valores[:8760]
            else:
                padded = np.zeros(8760)
                padded[:len(valores)] = valores
                return padded
        except Exception as e:
            print(f"   AVISO: Serie horaria '{nombre_variable}' no disponible: {e}")
            return np.zeros(8760)

    # ---- Extracción de KPIs anuales ----
    kwh_luz_anual      = obtener_energia_anual("Lights Electricity Energy")
    kwh_cooling_demand = obtener_energia_anual("Ideal Loads Cooling Energy")
    kwh_heating_demand = obtener_energia_anual("Ideal Loads Heating Energy")

    # ---- Series horarias para visualización ----
    serie_luz      = obtener_serie_horaria("Lights Electricity Energy")
    serie_cooling  = obtener_serie_horaria("Ideal Loads Cooling Energy")
    serie_heating  = obtener_serie_horaria("Ideal Loads Heating Energy")

    conn.close()

    # Nota: Las demandas vienen en J, ya convertidas a kWh en obtener_energia_anual()
    # El consumo real de equipos HVAC = demanda / COP (se aplica fuera de esta función)

    return {
        "kwh_iluminacion":    kwh_luz_anual,
        "kwh_cooling_demand": kwh_cooling_demand,
        "kwh_heating_demand": kwh_heating_demand,
        "serie_iluminacion":  serie_luz / 3_600_000.0,    # J a kWh por hora
        "serie_cooling":      serie_cooling / 3_600_000.0,
        "serie_heating":      serie_heating / 3_600_000.0,
    }

# ==========================================================
# CELDA 8: CURVA DE OPTIMIZACIÓN SFR (SPLIT-FLUX)
# ==========================================================

def simular_curva_sfr(
    ancho, largo, altura,
    epw_path,
    sfr_valores=None,
    tipo_uso="warehouse",
    domo_vlt=0.67, domo_shgc=0.48, domo_u=3.2,
    domo_ancho=1.3279, domo_largo=2.5465,
    cop_cooling=3.5, eff_heating=0.85,
    carpeta_salida="/content/simulaciones_sfr"
):
    """
    FUNCIÓN PRINCIPAL DEL MOTOR TÉRMICO.

    Simula la nave industrial con N valores de SFR (Sky Fraction Ratio),
    ejecutando EnergyPlus para cada caso y extrayendo los kWh reales.

    Retorna un DataFrame con la curva completa de Split-Flux:
    - ahorro_luz_kwh:     Ahorro por reducción de iluminación artificial
    - penalizacion_cooling_kwh: Carga extra de AC por calor solar del domo
    - ahorro_calefaccion_kwh:   Ahorro de calefacción por calor solar del domo
    - ahorro_neto_kwh:    Balance final (lo que maximizamos)

    Compatibilidad: La salida de esta función alimenta directamente
    tab_analitica en app.py de Streamlit.
    """
            f"EnergyPlus no genero .sql para '{nombre}'.\n"
            f"STDERR (ultimas 800 chars): {r_sim.stderr[-800:]}")

    kb = os.path.getsize(sql_path) / 1024
    print(f"    SQL generado: {kb:.0f} KB")
    return sql_path


# --- Verificar CLIs ---
print("CELDA 6: Verificando CLIs...")
import subprocess as _sp
_r1 = _sp.run(["energyplus", "--version"], capture_output=True, text=True)
_r2 = _sp.run(["honeybee-energy", "--help"], capture_output=True, text=True)
_ep_ok  = "EnergyPlus" in _r1.stdout
_hbe_ok = _r2.returncode == 0
print(f"  EnergyPlus      : {'OK' if _ep_ok  else 'NO ENCONTRADO -> re-ejecutar celda 1 + Restart'}")
print(f"  honeybee-energy : {'OK' if _hbe_ok else 'NO ENCONTRADO -> re-ejecutar celda 1 + Restart'}")
print("=" * 60)
if _ep_ok and _hbe_ok:
    print("CELDA 6 OK - ejecutar_simulacion_ep() lista.")
else:
    print("CELDA 6 ADVERTENCIA - CLIs no disponibles.")
    print("La simulacion fallara en celda 9.")
    print("Solucion: re-ejecutar celda 1, Runtime > Restart session.")
print("=" * 60)


# ##############################################################
# CELDA 7 - EXTRACCION DE RESULTADOS SQL
# ##############################################################

def extraer_resultados_sql(sql_path):
    """Lee .sql de EnergyPlus. Autosuficiente: imports internos."""
    import sqlite3
    import numpy as np
    import pandas as pd

    conn   = sqlite3.connect(sql_path)
    df_dic = pd.read_sql_query(
        "SELECT ReportDataDictionaryIndex, Name FROM ReportDataDictionary", conn)

    def kwh_anual(nombre):
        rows = df_dic[df_dic["Name"].str.contains(nombre, case=False, na=False)]
        if rows.empty:
            return 0.0
        idxs = ",".join(map(str, rows["ReportDataDictionaryIndex"].tolist()))
        res  = pd.read_sql_query(
            f"SELECT SUM(Value) as T FROM ReportData "
            f"WHERE ReportDataDictionaryIndex IN ({idxs})", conn)
        return float(res["T"].iloc[0] or 0.0) / 3_600_000.0  # J a kWh

    luz     = kwh_anual("Lights Electricity Energy")
    cooling = kwh_anual("Ideal Loads Cooling Energy")
    heating = kwh_anual("Ideal Loads Heating Energy")
    conn.close()

    return {"kwh_iluminacion": luz,
            "kwh_cooling_demand": cooling,
            "kwh_heating_demand": heating}


print("=" * 60)
print("CELDA 7 OK - extraer_resultados_sql() lista.")
print("=" * 60)


# ##############################################################
# CELDA 8 - MOTOR PRINCIPAL: CURVA SFR SPLIT-FLUX
# ##############################################################

def simular_curva_sfr(
    ancho, largo, altura, epw_path,
    sfr_valores=None, tipo_uso="warehouse",
    domo_vlt=0.67, domo_shgc=0.48, domo_u=3.2,
    domo_ancho=1.3279, domo_largo=2.5465,
    cop_cooling=3.5, eff_heating=0.85,
    carpeta_salida="/content/simulaciones_sfr"):
    """Motor principal Split-Flux. Autosuficiente: imports internos."""
    import os, math
    import numpy as np
    import pandas as pd

    if sfr_valores is None:
        sfr_valores = np.arange(0.01, 0.11, 0.01)

    os.makedirs(carpeta_salida, exist_ok=True)

    # --- CASO BASE: SFR = 0 (sin domos) ---
    print("\n" + "="*60)
    print("SIMULANDO CASO BASE (SFR = 0%)...")
    print("="*60)

    # Para SFR=0 usamos SFR mínimo funcional (no se pueden hacer 0 domos en EnergyPlus)
    # pero le ponemos VLT=0 y SHGC=0 para emular "sin domos"
    modelo_base, _, params_base = construir_modelo_hb(
        ancho, largo, altura,
        sfr=0.001,  # 1 domo simbólico
        domo_ancho=domo_ancho, domo_largo=domo_largo,
        tipo_uso=tipo_uso,
        domo_vlt=0.001,   # Opaco: no deja pasar luz
        domo_shgc=0.001,  # Sin ganancia solar
        domo_u=domo_u,
        identifier_sufijo="base"
    )

    sql_base = ejecutar_simulacion_ep(
        modelo_base, epw_path, params_base,
        carpeta_salida, nombre="caso_base"
    )
    resultados_base = extraer_resultados_sql(sql_base)

    kwh_luz_base      = resultados_base["kwh_iluminacion"]
    kwh_cooling_base  = resultados_base["kwh_cooling_demand"] / cop_cooling
    kwh_heating_base  = resultados_base["kwh_heating_demand"] / eff_heating

    print("\nCASO BASE:")
    print(f"   Iluminacion:  {kwh_luz_base:,.0f} kWh/anio")
    print(f"   Cooling:      {kwh_cooling_base:,.0f} kWh/anio")
    print(f"   Heating:      {kwh_heating_base:,.0f} kWh/anio")
    print(f"   TOTAL BASE:   {kwh_luz_base + kwh_cooling_base + kwh_heating_base:,.0f} kWh/anio")

    # --- CASOS SFR ---
    resultados_sfr = []

    for sfr in sfr_valores:
        sfr_pct = sfr * 100
        nombre_caso = f"caso_sfr_{sfr_pct:.0f}pct"
        print(f"\n--- Simulando SFR = {sfr_pct:.0f}% ---")

        try:
            modelo_sfr, sfr_real, params_sfr = construir_modelo_hb(
    # CASO BASE (sin domos: VLT y SHGC casi cero)
    print("\n" + "=" * 60)
    print("CASO BASE (sin luz natural)...")
    print("=" * 60)
    m_base, _, p_base = construir_modelo_hb(
        ancho, largo, altura, sfr=0.001,
        domo_ancho=domo_ancho, domo_largo=domo_largo,
        tipo_uso=tipo_uso, domo_vlt=0.001, domo_shgc=0.001,
        domo_u=domo_u, identifier_sufijo="base")

    sql_base = ejecutar_simulacion_ep(
        m_base, epw_path, p_base, carpeta_salida, nombre="caso_base")
    r_base = extraer_resultados_sql(sql_base)

    kwh_luz_b  = r_base["kwh_iluminacion"]
    kwh_cool_b = r_base["kwh_cooling_demand"] / cop_cooling
    kwh_heat_b = r_base["kwh_heating_demand"] / eff_heating

    print(f"  Iluminacion base : {kwh_luz_b:,.0f} kWh/anio")
    print(f"  Cooling base     : {kwh_cool_b:,.0f} kWh/anio")
    print(f"  Heating base     : {kwh_heat_b:,.0f} kWh/anio")
    print(f"  TOTAL base       : {kwh_luz_b+kwh_cool_b+kwh_heat_b:,.0f} kWh/anio")

    # CASOS SFR
    filas = []
    total = len(sfr_valores)
    for idx, sfr in enumerate(sfr_valores, 1):
        sfr_pct = sfr * 100
        print(f"\n[{idx}/{total}] SFR = {sfr_pct:.0f}%...")
        try:
            m_sfr, sfr_real, p_sfr = construir_modelo_hb(
                ancho, largo, altura, sfr,
                domo_ancho=domo_ancho, domo_largo=domo_largo,
                tipo_uso=tipo_uso,
                domo_vlt=domo_vlt, domo_shgc=domo_shgc, domo_u=domo_u,
                identifier_sufijo=f"sfr{sfr_pct:.0f}"
            )

            sql_sfr = ejecutar_simulacion_ep(
                modelo_sfr, epw_path, params_sfr,
                carpeta_salida, nombre=nombre_caso
            )
            res = extraer_resultados_sql(sql_sfr)

            kwh_luz_sfr      = res["kwh_iluminacion"]
            kwh_cooling_sfr  = res["kwh_cooling_demand"] / cop_cooling
            kwh_heating_sfr  = res["kwh_heating_demand"] / eff_heating

            # ---- CÁLCULO DEL SPLIT-FLUX (Flujo Dividido) ----
            # Exactamente la lógica del VBA: Savings = Base - Design
            ahorro_luz       = kwh_luz_base - kwh_luz_sfr          # + = ahorro
            penalizacion_cool= kwh_cooling_sfr - kwh_cooling_base   # + = más consumo
            ahorro_heat      = kwh_heating_base - kwh_heating_sfr   # + = ahorro
            ahorro_neto      = ahorro_luz - penalizacion_cool + ahorro_heat

            resultado = {
                "sfr_pct":              sfr_pct,
                "sfr_real_pct":         sfr_real * 100,
                "num_domos":            math.ceil((ancho * largo * sfr) / (domo_ancho * domo_largo)),
                # Consumos absolutos
                "kwh_luz_base":         kwh_luz_base,
                "kwh_luz_sfr":          kwh_luz_sfr,
                "kwh_cooling_base":     kwh_cooling_base,
                "kwh_cooling_sfr":      kwh_cooling_sfr,
                "kwh_heating_base":     kwh_heating_base,
                "kwh_heating_sfr":      kwh_heating_sfr,
                # Split-Flux (igual que columnas de Graph_Results en VBA)
                "ahorro_luz_kwh":       ahorro_luz,
                "penalizacion_cool_kwh": penalizacion_cool,
                "ahorro_heat_kwh":      ahorro_heat,
                "ahorro_neto_kwh":      ahorro_neto,
                # Autonomía lumínica (sDA estimada)
                "sda_estimada_pct":     min(100, (sfr_real / 0.04) * 45),  # heurística
            }

            resultados_sfr.append(resultado)

            print(f"   Ahorro luz:    {ahorro_luz:+,.0f} kWh/anio")
            print(f"   Penaliz. AC:  {penalizacion_cool:+,.0f} kWh/anio")
            print(f"   Ahorro heat:  {ahorro_heat:+,.0f} kWh/anio")
            print(f"   Ahorro NETO:  {ahorro_neto:+,.0f} kWh/anio")

        except Exception as e:
            print(f"   ERROR en SFR {sfr_pct:.0f}%: {e}")
            continue

    df_resultados = pd.DataFrame(resultados_sfr)
    return df_resultados, resultados_base

# ==========================================================
# CELDA 9: VISUALIZACIÓN (Gráficos Plotly para Streamlit)
# ==========================================================

def graficar_curva_optimizacion(df_resultados):
    """
    Genera la gráfica interactiva de Split-Flux / Rendimientos Decrecientes.
    Compatible directamente con st.plotly_chart() en Streamlit.
    """
    if df_resultados.empty:
        print("ERROR: No hay datos para graficar.")
        return None

    sfr_optimo = df_resultados.loc[df_resultados["ahorro_neto_kwh"].idxmax(), "sfr_pct"]
    ahorro_max = df_resultados["ahorro_neto_kwh"].max()

    fig = go.Figure()

    # Línea de ahorro en iluminación
    fig.add_trace(go.Scatter(
        x=df_resultados["sfr_pct"],
        y=df_resultados["ahorro_luz_kwh"],
        name="Ahorro Iluminacion",
        line=dict(color="#3498DB", width=2, dash="dash"),
        hovertemplate="SFR %{x:.0f}%: %{y:,.0f} kWh<extra></extra>"
    ))

    # Línea de penalización AC (positivo = más consumo)
    fig.add_trace(go.Scatter(
        x=df_resultados["sfr_pct"],
        y=-df_resultados["penalizacion_cool_kwh"],   # Negativo para mostrar penalización
        name="Penalizacion AC",
        line=dict(color="#E74C3C", width=2),
        hovertemplate="SFR %{x:.0f}%: %{y:,.0f} kWh<extra></extra>"
    ))

    # Ahorro en calefacción
    fig.add_trace(go.Scatter(
        x=df_resultados["sfr_pct"],
        y=df_resultados["ahorro_heat_kwh"],
        name="Ahorro Calefaccion",
        line=dict(color="#F39C12", width=2, dash="dot"),
        hovertemplate="SFR %{x:.0f}%: %{y:,.0f} kWh<extra></extra>"
    ))

    # AHORRO NETO TOTAL (línea principal)
    fig.add_trace(go.Scatter(
        x=df_resultados["sfr_pct"],
        y=df_resultados["ahorro_neto_kwh"],
        name="AHORRO NETO TOTAL",
        line=dict(color="#2ECC71", width=4),
        hovertemplate="SFR %{x:.0f}%: %{y:,.0f} kWh<extra></extra>",
        fill="tozeroy",
        fillcolor="rgba(46, 204, 113, 0.1)"
    ))

    # Línea vertical del SFR óptimo
    fig.add_vline(
        x=sfr_optimo,
        line_width=2,
        line_dash="solid",
        line_color="#8E44AD",
        annotation_text=f"SFR Optimo: {sfr_optimo:.0f}%<br>Ahorro max: {ahorro_max:,.0f} kWh/anio",
        annotation_position="top right",
        annotation_font_color="#8E44AD"
    )

    fig.update_layout(
        title={
            "text": "Curva de Optimizacion Sunoptics (Motor EnergyPlus)",
            "font": {"size": 18}
        },
        xaxis_title="Skylight to Floor Ratio - SFR (%)",
        yaxis_title="Energía Anual (kWh/anio)",
        hovermode="x unified",
        template="plotly_white",
        height=500,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        annotations=[dict(
            x=0.02, y=0.02,
            xref="paper", yref="paper",
            text="<i>Motor: EnergyPlus 23.2 | Datos: TMYx EPW | Honeybee Energy</i>",
            showarrow=False,
            font=dict(size=10, color="gray")
        )]
    )

                identifier_sufijo=f"sfr{sfr_pct:.0f}")

            sql_sfr = ejecutar_simulacion_ep(
                m_sfr, epw_path, p_sfr,
                carpeta_salida, nombre=f"caso_sfr_{sfr_pct:.0f}pct")
            r = extraer_resultados_sql(sql_sfr)

            kwh_luz_s  = r["kwh_iluminacion"]
            kwh_cool_s = r["kwh_cooling_demand"] / cop_cooling
            kwh_heat_s = r["kwh_heating_demand"] / eff_heating

            # Split-Flux: Savings = Base - Design
            a_luz   = kwh_luz_b  - kwh_luz_s    # positivo = ahorro
            p_cool  = kwh_cool_s - kwh_cool_b   # positivo = penalizacion
            a_heat  = kwh_heat_b - kwh_heat_s   # positivo = ahorro
            a_neto  = a_luz - p_cool + a_heat

            filas.append({
                "sfr_pct":               sfr_pct,
                "sfr_real_pct":          sfr_real * 100,
                "num_domos":             math.ceil((ancho*largo*sfr)/(domo_ancho*domo_largo)),
                "kwh_luz_base":          kwh_luz_b,
                "kwh_luz_sfr":           kwh_luz_s,
                "kwh_cooling_base":      kwh_cool_b,
                "kwh_cooling_sfr":       kwh_cool_s,
                "kwh_heating_base":      kwh_heat_b,
                "kwh_heating_sfr":       kwh_heat_s,
                "ahorro_luz_kwh":        a_luz,
                "penalizacion_cool_kwh": p_cool,
                "ahorro_heat_kwh":       a_heat,
                "ahorro_neto_kwh":       a_neto,
            })
            print(f"  Ahorro luz    : {a_luz:+,.0f} kWh/anio")
            print(f"  Penaliz. AC   : {p_cool:+,.0f} kWh/anio")
            print(f"  Ahorro heat   : {a_heat:+,.0f} kWh/anio")
            print(f"  AHORRO NETO   : {a_neto:+,.0f} kWh/anio  <---")

        except Exception as e:
            print(f"  ERROR en SFR {sfr_pct:.0f}%: {e}")
            continue

    return pd.DataFrame(filas), r_base


print("=" * 60)
print("CELDA 8 OK - simular_curva_sfr() lista.")
print("=" * 60)


# ##############################################################
# CELDA 9 - VISUALIZACION
# ##############################################################

def graficar_curva_optimizacion(df):
    """Grafica Split-Flux con Plotly."""
    import plotly.graph_objects as go
    if df is None or df.empty:
        print("ERROR: DataFrame vacio.")
        return None

    sfr_opt = df.loc[df["ahorro_neto_kwh"].idxmax(), "sfr_pct"]
    a_max   = df["ahorro_neto_kwh"].max()

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df["sfr_pct"], y=df["ahorro_luz_kwh"],
        name="Ahorro Iluminacion",
        line=dict(color="#3498DB", width=2, dash="dash")))
    fig.add_trace(go.Scatter(x=df["sfr_pct"], y=-df["penalizacion_cool_kwh"],
        name="Penalizacion AC",
        line=dict(color="#E74C3C", width=2)))
    fig.add_trace(go.Scatter(x=df["sfr_pct"], y=df["ahorro_heat_kwh"],
        name="Ahorro Calefaccion",
        line=dict(color="#F39C12", width=2, dash="dot")))
    fig.add_trace(go.Scatter(x=df["sfr_pct"], y=df["ahorro_neto_kwh"],
        name="AHORRO NETO",
        line=dict(color="#2ECC71", width=4),
        fill="tozeroy", fillcolor="rgba(46,204,113,0.1)"))
    fig.add_vline(x=sfr_opt, line_width=2, line_dash="solid", line_color="#8E44AD",
        annotation_text=f"SFR Optimo: {sfr_opt:.0f}% | Max: {a_max:,.0f} kWh/anio",
        annotation_position="top right", annotation_font_color="#8E44AD")
    fig.update_layout(
        title="Curva de Optimizacion Sunoptics (Motor EnergyPlus)",
        xaxis_title="SFR (%)", yaxis_title="kWh/anio",
        hovermode="x unified", template="plotly_white", height=500)
    fig.show()
    return fig


def graficar_heatmap_ahorro(df_resultados):
    """Tabla de KPIs de ahorro por SFR."""
    if df_resultados.empty:
        return None

    fig = go.Figure(data=[go.Table(
        header=dict(
            values=["SFR %", "# Domos", "Ahorro Luz<br>(kWh)", "Penaliz. AC<br>(kWh)",
                    "Ahorro Heat<br>(kWh)", "<b>AHORRO NETO<br>(kWh)</b>"],
            fill_color="#2C3E50",
            font=dict(color="white", size=12),
            align="center"
        ),
        cells=dict(
            values=[
                df_resultados["sfr_pct"].apply(lambda x: f"{x:.0f}%"),
                df_resultados["num_domos"].astype(int),
                df_resultados["ahorro_luz_kwh"].apply(lambda x: f"{x:,.0f}"),
                df_resultados["penalizacion_cool_kwh"].apply(lambda x: f"{x:,.0f}"),
                df_resultados["ahorro_heat_kwh"].apply(lambda x: f"{x:,.0f}"),
                df_resultados["ahorro_neto_kwh"].apply(lambda x: f"<b>{x:,.0f}</b>"),
            ],
            fill_color=[["#ECF0F1", "#FDFEFE"] * 10],
            font=dict(size=11),
            align="center"
        )
    )])
    fig.update_layout(title="Tabla de Resultados Split-Flux por SFR", height=400)
    fig.show()
    return fig

def main():
    print("SKYCALC 2.0 - MOTOR ENERGYPLUS | ECO CONSULTOR")
    print("=" * 60)

    # 1. Descargar EPW
    try:
        epw_path = descargar_epw_onebuilding(LAT, LON, carpeta_destino="/content")
    except Exception as e:
        print(f"No se pudo descargar EPW automaticamente: {e}")
        print("Usando EPW de prueba (Chicago) para validar el motor...")
        epw_url = "https://raw.githubusercontent.com/ladybug-tools/ladybug/master/tests/epw/chicago.epw"
        epw_path = "/content/test_chicago.epw"
        try:
            urllib.request.urlretrieve(epw_url, epw_path)
        except Exception as e2:
            print(f"Fallo EPW de respaldo tambien: {e2}")
            return None

    print(f"\nEPW listo: {epw_path}\n")

    # 2. Ejecutar curva de optimizacion
    df_resultados, resultados_base = simular_curva_sfr(
        ancho=ANCHO,
        largo=LARGO,
        altura=ALTURA,
        epw_path=epw_path,
        sfr_valores=SFR_VALORES,
        tipo_uso=TIPO_USO,
        domo_vlt=DOMO_VLT,
        domo_shgc=DOMO_SHGC,
        domo_u=DOMO_U,
        domo_ancho=DOMO_ANCHO,
        domo_largo=DOMO_LARGO,
        cop_cooling=COP_COOLING,
        eff_heating=EFF_HEATING,
    )

    if df_resultados is None or df_resultados.empty:
        print("No se obtuvieron resultados. Revisar errores arriba.")
        return None

    # 3. Visualizar
    print("\n" + "=" * 60)
    print("GENERANDO GRAFICOS...")
    print("=" * 60)
    graficar_curva_optimizacion(df_resultados)
    graficar_heatmap_ahorro(df_resultados)

    # 4. Guardar CSV para Streamlit
    csv_path = "/content/resultados_sfr_curva.csv"
    df_resultados.to_csv(csv_path, index=False)
    print(f"\nResultados guardados en: {csv_path}")
    print("Subir este CSV al repositorio de Streamlit para")
    print("visualizacion instantanea sin re-ejecutar EnergyPlus.\n")

    # 5. Resumen ejecutivo
    idx_optimo = df_resultados["ahorro_neto_kwh"].idxmax()
    fila_optima = df_resultados.iloc[idx_optimo]

    print("=" * 60)
    print("RESUMEN EJECUTIVO")
    print("=" * 60)
    print(f"SFR OPTIMO:          {fila_optima['sfr_pct']:.0f}%")
    print(f"DOMOS RECOMENDADOS:  {int(fila_optima['num_domos'])} unidades")
    print(f"Ahorro Iluminacion:  {fila_optima['ahorro_luz_kwh']:,.0f} kWh/anio")
    print(f"Penalizacion AC:    -{fila_optima['penalizacion_cool_kwh']:,.0f} kWh/anio")
    print(f"Ahorro Calefaccion:  {fila_optima['ahorro_heat_kwh']:,.0f} kWh/anio")
    print(f"AHORRO NETO TOTAL:   {fila_optima['ahorro_neto_kwh']:,.0f} kWh/anio")
    print("=" * 60)

    return df_resultados


# EJECUTAR
df = main()
if df is not None:
    print(df[["sfr_pct", "ahorro_luz_kwh", "penalizacion_cool_kwh",
              "ahorro_heat_kwh", "ahorro_neto_kwh"]].to_string(index=False))

# ==========================================================
# CELDA 11: FUNCIÓN EXPORTABLE PARA STREAMLIT
# ==========================================================
# Esta función es la interfaz limpia que se importa desde app.py

def simular_nave_sunoptics(
    ancho, largo, altura,
    domo_vlt, domo_shgc, domo_u, domo_ancho, domo_largo,
    sfr_target,
    epw_path,
    tipo_uso="warehouse",
    cop_cooling=3.5,
    eff_heating=0.85,
):
    """
    INTERFAZ PÚBLICA PARA STREAMLIT.

    Uso en app.py:
        from motor_termico import simular_nave_sunoptics
        resultados = simular_nave_sunoptics(
            ancho=ancho_nave, largo=largo_nave, altura=alto_nave,
            domo_vlt=datos_domo['VLT'], domo_shgc=datos_domo['SHGC'],
            domo_u=datos_domo['U_Value'], domo_ancho=datos_domo['Ancho_m'],
            domo_largo=datos_domo['Largo_m'], sfr_target=sfr_target,
            epw_path=epw_path_from_weather_utils,
        )

    Retorna dict con:
        - df_curva: DataFrame con curva de optimización SFR
        - sfr_optimo: float (%)
        - ahorro_neto_optimo: float (kWh/anio)
        - kwh_luz_base: float
        - fig_curva: figura Plotly
    """
    import tempfile

    carpeta_tmp = tempfile.mkdtemp(prefix="skycalc_sim_")

    sfr_valores = np.arange(0.01, 0.11, 0.01)

    df_curva, resultados_base = simular_curva_sfr(
        ancho=ancho, largo=largo, altura=altura,
        epw_path=epw_path,
        sfr_valores=sfr_valores,
        tipo_uso=tipo_uso,
        domo_vlt=domo_vlt, domo_shgc=domo_shgc, domo_u=domo_u,
        domo_ancho=domo_ancho, domo_largo=domo_largo,
        cop_cooling=cop_cooling, eff_heating=eff_heating,
        carpeta_salida=carpeta_tmp
    )

    if df_curva.empty:
        return None

    idx_optimo = df_curva["ahorro_neto_kwh"].idxmax()
    fila_optima = df_curva.iloc[idx_optimo]
    fig_curva = graficar_curva_optimizacion(df_curva)

    return {
        "df_curva":            df_curva,
        "sfr_optimo_pct":      fila_optima["sfr_pct"],
        "num_domos_optimo":    int(fila_optima["num_domos"]),
        "ahorro_luz_kwh":      fila_optima["ahorro_luz_kwh"],
        "penalizacion_cool_kwh": fila_optima["penalizacion_cool_kwh"],
        "ahorro_heat_kwh":     fila_optima["ahorro_heat_kwh"],
        "ahorro_neto_kwh":     fila_optima["ahorro_neto_kwh"],
        "kwh_luz_base":        resultados_base["kwh_iluminacion"],
        "fig_curva":           fig_curva,
    }

# ==========================================================
# PUNTO DE ENTRADA
# ==========================================================
# EJECUTAR
df = main()
if df is not None:
    print(df[["sfr_pct", "ahorro_luz_kwh", "penalizacion_cool_kwh",
              "ahorro_heat_kwh", "ahorro_neto_kwh"]].to_string(index=False))
def graficar_tabla_resultados(df):
    """Tabla interactiva de resultados."""
    import plotly.graph_objects as go
    if df is None or df.empty:
        return None
    fig = go.Figure(data=[go.Table(
        header=dict(
            values=["SFR %", "Domos", "Ahorro Luz", "Penaliz. AC",
                    "Ahorro Heat", "AHORRO NETO"],
            fill_color="#2C3E50", font=dict(color="white", size=12), align="center"),
        cells=dict(
            values=[
                df["sfr_pct"].apply(lambda x: f"{x:.0f}%"),
                df["num_domos"].astype(int),
                df["ahorro_luz_kwh"].apply(lambda x: f"{x:,.0f} kWh"),
                df["penalizacion_cool_kwh"].apply(lambda x: f"{x:,.0f} kWh"),
                df["ahorro_heat_kwh"].apply(lambda x: f"{x:,.0f} kWh"),
                df["ahorro_neto_kwh"].apply(lambda x: f"{x:,.0f} kWh"),
            ],
            fill_color=[["#ECF0F1", "#FDFEFE"] * 10],
            font=dict(size=11), align="center"))])
    fig.update_layout(title="Resultados Split-Flux por SFR", height=420)
    fig.show()
    return fig


print("=" * 60)
print("CELDA 9 OK - funciones de graficacion listas.")
print("=" * 60)


# ##############################################################
# CELDA 10 - EJECUCION PRINCIPAL
# Aqui es donde EnergyPlus realmente corre. Tarda ~15-30 min.
# ##############################################################

import os as _os
print("CELDA 10: Iniciando motor termico...")
print("=" * 60)

# Verificar EPW
if not _os.path.exists(epw_path):
    print(f"ERROR: EPW no encontrado en {epw_path}")
    print("Volver a ejecutar celda 4.")
else:
    print(f"EPW     : {epw_path}")
    print(f"Nave    : {ANCHO}m x {LARGO}m x {ALTURA}m | {TIPO_USO}")
    print(f"Casos   : {len(SFR_VALORES)} SFR + 1 caso base = {len(SFR_VALORES)+1} simulaciones")
    print(f"Tiempo estimado: ~{(len(SFR_VALORES)+1) * 2}-{(len(SFR_VALORES)+1) * 4} min")
    print("=" * 60)

    try:
        df_resultados, resultados_base = simular_curva_sfr(
            ancho=ANCHO, largo=LARGO, altura=ALTURA,
            epw_path=epw_path,
            sfr_valores=SFR_VALORES,
            tipo_uso=TIPO_USO,
            domo_vlt=DOMO_VLT, domo_shgc=DOMO_SHGC, domo_u=DOMO_U,
            domo_ancho=DOMO_ANCHO, domo_largo=DOMO_LARGO,
            cop_cooling=COP_COOLING, eff_heating=EFF_HEATING,
        )

        if df_resultados is None or df_resultados.empty:
            print("ERROR: No se obtuvieron resultados.")
        else:
            # CSV para Streamlit
            csv_path = "/content/resultados_sfr_curva.csv"
            df_resultados.to_csv(csv_path, index=False)

            # Resumen ejecutivo
            idx_opt  = df_resultados["ahorro_neto_kwh"].idxmax()
            fila_opt = df_resultados.iloc[idx_opt]

            print("\n" + "=" * 60)
            print("RESUMEN EJECUTIVO")
            print("=" * 60)
            print(f"SFR OPTIMO          : {fila_opt['sfr_pct']:.0f}%")
            print(f"DOMOS RECOMENDADOS  : {int(fila_opt['num_domos'])} unidades")
            print(f"Ahorro Iluminacion  : {fila_opt['ahorro_luz_kwh']:,.0f} kWh/anio")
            print(f"Penalizacion AC     : {fila_opt['penalizacion_cool_kwh']:,.0f} kWh/anio")
            print(f"Ahorro Calefaccion  : {fila_opt['ahorro_heat_kwh']:,.0f} kWh/anio")
            print(f"AHORRO NETO TOTAL   : {fila_opt['ahorro_neto_kwh']:,.0f} kWh/anio")
            print("=" * 60)
            print(f"CSV guardado en     : {csv_path}")
            print("")

            # Graficas
            print("Generando graficas...")
            graficar_curva_optimizacion(df_resultados)
            graficar_tabla_resultados(df_resultados)

            # Tabla texto
            print("\nTABLA COMPLETA:")
            print(df_resultados[[
                "sfr_pct", "num_domos",
                "ahorro_luz_kwh", "penalizacion_cool_kwh",
                "ahorro_heat_kwh", "ahorro_neto_kwh"
            ]].to_string(index=False))

            print("\n" + "=" * 60)
            print("CELDA 10 OK - SIMULACION COMPLETADA.")
            print("=" * 60)

    except Exception as _e10:
        import traceback
        print(f"\nERROR EN SIMULACION: {_e10}")
        print("-" * 60)
        traceback.print_exc()
        print("-" * 60)
        print("Diagnostico:")
        print("  1. EnergyPlus no disponible? -> re-ejecutar celda 1 + Restart")
        print("  2. EPW no descargado?        -> re-ejecutar celda 4")
        print("  3. honeybee-energy fallo?    -> ver traceback arriba")
